# TypeScript Introduction

In this course, you will learn about: TypeScript

## What is TS and Why Would We Use it?

**TypeScript** is **JavaScript** but it adds more features, more syntax features we can use. Browsers don't know how to execute **TypeScript**, they know how to execute **JavaScript**. **TypeScript** is a superset to **JavaScript**.

Why would we use it?

- Adds static types
- Adds some new features
- Compiles next-gen **JavaScript** to **old JavaScript**

One of these features is:

```js
// in js
function add(a, b) {
    return a + b;
}

add("15", "8"); // "158"


// in ts
function add2(a: string, b: string) {
  return a + b;
}

add2("15", "8"); // "158"
```

## Working with TypeScript

First of all, we need to install **TypeScript** with this official website: <https://www.typescriptlang.org/>

You can also use `npm install -g typescript` command in windows. In MAC or GNU/Linux you must use `sudo npm install -g typescript` command to access permission.

To start **TypeScript**, we need to add a new file with `.ts` extension (e.g. `app.ts`).

**TypeScript**, as we mentioned, builds up on **JavaScript**, so generally we can write noraml **JavaScript** code in here. Indeed, any **JavaScript** code works in a **TypeScript** file. But we can then also add certain features which only work in **TypeScript** (i.e. **JavaScript++**).

For example, consider this code:

```ts
// app.ts
function add(a, b) {
  return a + b;
}

const result = add("15", "8");

console.log(result);
```

We can compile this code into **JavaScript** file with `tsc app.ts` command. `tsc` is for **TypeScript**. After compilation, new file will be created that called `app.js` and now we can use that code for browsers. The interesting part for **TypeScript** is, after compilation, **JavaScript** file also converts to old version, for example:

```js ts
// app.ts
function add(a, b) {
  return a + b;
}

const result = add("15", "8");

console.log(result);

// now we use `tsc app.ts` command
// app.js created by tsc
function add(a, b) {
  return a + b;
}
var result = add("15", "8");
console.log(result); // "158"
```

As we mentioned, **TypeScript** also converts code that runs in older browsers as well, this is a extra benefit we get. So that code above is actually **JavaScript** code which also runs in older browsers.

Let's look at the result above, we got `"153"` as output. But we want to `23` as output, how can we do this?

We can add a type assignment here, for example for parameters. We can make it clear to the **TypeScript** compiler that `a` should be a number and `b` should be a number. We do that by adding a `:` colon after the parameter where we want to assign a type, and then we write the type name (e.g. `number`). It means that `add(a: number, b: number) { .. }`:

```ts
function add(a: number, b: number) {
  return a + b;
}

const result = add(15, 8);

console.log(result);
```

## Extra Features

**TypeScript** has a built-in feature which is called **type inference**. Which means **TypeScript** is really doing its best and it's really smart, about inferring types we're working with. For example, we can write this code:

```ts
function add(a: number, b: number) {
  return a + b;
}

// hover over `add()` function => function add(a: number, b: number): number
const result = add(15, 8);

console.log(result);
```

It actually inferred the **return type** of the `add()` function. Since we store the **return value** of the `add()` function in `result`, **TypeScript** also infers that `result` holds the number. So **type inference** is a really a key feature of **TypeScript** as well; and it's a good practice to not unnecessarily reassign a type, **TypeScript** could infer anyways. For example, we don't have to assign the `number` in front of `result` constant:

```ts
function add(a: number, b: number) {
  return a + b;
}

const result: number = add(15, 8);

console.log(result);
```

We don't have to add it, **TypeScript** automatically detect that `result` as a `number` type.

## More on Core Types

All types in **TypeScript**:

- `number` type
- `string` type
- `boolean` (boolean, true, false)
- function types (a type of the function as a whole)
- objects types
- `void` type
- `undefined` type
- `any` type
- `null` type
- and so on

> boolean

We have `boolean` type, for example:

```ts
const isDone = false;
// on hover: const isDone: false

let isDone = false;
// on hover: let isDone: boolean
```

As you can see, the second one is changeable, it means that we can change it to `true` in future.

> function, string

We also have **return type** in **TypeScript** language which means that we can return any type in function that called **function type**:

```ts
function add(a, b): string {
  return a + b;
}

const result = add("15", "8");
```

As you can see, we add a `string` type in front of `add()` function. Let's try another example:

```ts
function add(a: string, b: string): string {
  return a + b;
}

const result = add("15", "8");
```

So we have **parameter type** and **return type** (function type) here.

> void, undefined

We can also have functions that don't return anything. Consider:

```ts
function add(a: number, b: number) {
  return a + b;
}

function printResult(result) {
  console.log(result);
}

const result = add(15, 8);

printResult(result);
```

`printResult()` function doesn't return anything. We can make clear that this function won't return anything by adding a return type of `void` here:

```ts
function add(a: number, b: number) {
  return a + b;
}

function printResult(result): void {
  console.log(result);
}

const result = add(15, 8);

printResult(result);
```

That's a type added by **TypeScript** and this basically means this function has no return statement. We can also use `undefined` type instead of `void`. But we getting an error, because technically a function that doesn't return anything, returns `undefined` in **JavaScript**, but in **TypeScript** there is a slight differentiation between these cases. So for a better practice, use `void` type. `undefiend` type is a bad practice.

> any

We can use the `any` type in our code:

```ts
let a; // any type
```

## Extra Features (2)

Another way of working with types and we can override type inference. Consider:

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TypeScript</title>
</head>

<body>
    <input type="text" id="num1">
    <input type="text" id="num2">
    <button>Add</button>
</body>

</html>
```

and

```ts
const num1Input = document.getElementById("num1");
const num2Input = document.getElementById("num2");
const addBtn = document.querySelector("button");

function add(a: number, b: number) {
  return a + b;
}

function printResult(result) {
  console.log(result);
}

addBtn.addEventListener("click", () => {
  const num1 = num1Input.value;
  const num2 = num2Input.value;
  const result = add(num1, num2);
  printResult(result);
});
```

If we compile this code, we'll get the bad result (string concatination), **TypeScript** doesn't understand the `value` property on `num1Input` and `num2Input`. If you hover over it, you'll see the `any` type. How can we fix this problem?

We only tell **TypeScript** that we select an element in the DOM by `id`Ùˆ but this could be an element; we can have any `id` on any element, it could be a paragraph, it could be a button, it could be a list item, it doesn't have to be an input element. If we hover over `getElementById()`, we indeed see the **TypeScript** only infers that this is of type `HTMLElement`; and that's of course very unspecific, it just means any `HTMLElement`, not specifically an `input` element.

Now we of course know as a developer that we will get an input element (i.e. `HTMLInputElement`) here. **TypeScript** doesn't scan our `index.html` file to check what we're selecting there; so we can't rely on type inference here. Instead we can do something which is known as a type casting. We can override the inference made by **TypeScript**. We can tell **TypeScript** that this will be of a different type. We can use:

```ts
const num1Input: HTMLInputElement = document.getElementById("num1");
const num2Input: HTMLInputElement = document.getElementById("num2");
```

But we still get an error. So instead, we'll use this type casting thing we mentioned, we do that by adding the `as` keyword after the thing, where **TypeScript** infers some type which we want to change and then we set the type we want to use instead of the type **TypeScript** inferred:

```ts
const num1Input = document.getElementById("num1") as HTMLInputElement;
const num2Input = document.getElementById("num2") as HTMLInputElement;
```

This is pure **TypeScript** sytax, this will all be lost once we convert it to **JavaScript**. We can also use `< >` angle brackets in front of the thing we want to cast, instead of after it as we do it with `as` keyword, and then we use the type here:

```ts
const num1Input = <HTMLInputElement>document.getElementById("num1");
const num2Input = <HTMLInputElement>document.getElementById("num2");
```

Both works, previous syntax is a bit more common now but both does the same thing in the end.

**Important**: It's important to understand that the value property on an `input` element, always returns a **string**; no matter which type this input (i.e. `<input type="text" id="someid">`) is of. So even if you set this to type `number` here, this doesn't change the type of value you get from the **value prop**, and it also does not change with the value the user entered. If a user enters the number `10` into an input, it's still a `string`, it's wrapped into quotes. **Value always gives you a string**.

We need to parse these:

```ts
const num1 = num1Input.value;
const num2 = num2Input.value;
const result = add(num1, num2);
```

strings to numbers, so we can add a `+` plus in front of both value it rerieves here to cast the string into a number.

```ts
const num1Input = <HTMLInputElement>document.getElementById("num1");
const num2Input = <HTMLInputElement>document.getElementById("num2");
const addBtn = document.querySelector("button");

function add(a: number, b: number) {
  return a + b;
}

function printResult(result) {
  console.log(result);
}

addBtn.addEventListener("click", () => {
  const num1 = +num1Input.value;
  const num2 = +num2Input.value;
  const result = add(num1, num2);
  printResult(result);
});
```

Now we get the additions in a mathematical sense instead of the concatenated strings.
