# Events - Mouse Click, Hover and son on

In this course, you learn about:

- A Closer Look at Events
- Event Propagation
- Drag & Drop

## Event Introduction

We can run code upon certain events. In browser-side, we use `addEventListener` method and in server-side (like NodeJs), we use `on` method.

- Browser-side: `addEventListener('...', event => ...)`
- Server-side: `on('...', event => ...)`

It's important to understand that we have different kinds of events we can listen to. **a click on a button or a click on anything else, a right click or a double click, hovering over something or moving the mouse button away from something**; these are all different kinds of events.

**Note**: Events typically transport data.

We have an `Event` constructor function, a core event object you could say with some core functionalities which all events share.

You learned how you can add an event listener to a button. You first of all select the button, for example with `querySelector()` or with `getElementById()` and then you can use the `addEventListener` method which exists on any DOM node basically to attach an event to it.

Let's show you two other ways of adding events.

> **One** is a way that is pretty old and which you shouldn't use anymore, still for completeness sake, we want to show it to you.

You can go right to the HTML node in your HTML code and there, you can add an attribute. For example, `onclick`:

```html
<button onclick="alert('Hello!');">Click on me</button>
```

This is not an arbitrary name chosen by us. There are various `on` attributes for different events that this element supports. So, if we click on that button, the output result will be `"Hello!"` (in `alert()` method (function)).

**Warning**: Don't mix HTML and HTML attributes and **JavaScript** code, it's absolutely not a recommended practice. You should register events in your **JavaScript** file instead.

> **Two**, we also have another way of adding an event. It's pretty close to what we did here in HTML. **Just this time in JavaScript**.

```js
const button = document.querySelector("button");

button.onclick = function () {
  alert("Hello!");
};
```

Or we can use arrow function for this way, for example:

```js
const button = document.querySelector("button");

const clickButtonHandler = () => {
  alert("Hello!");
};

button.onclick = clickButtonHandler;
```

**Note**: Don't execute this function right away, instead as with the event listener, point at it.

**Warning**: We can't use `button.onclick ..` twice. The reason for that is that we simply override the value which is stored in this property. So this (value or function) is not added or appended as a listener, it's simply overriding the old listener. For example:

```js
const button = document.querySelector("button");

const clickButtonHandler = () => {
  alert("Hello!");
};

const clickButtonHandler2 = () => {
  console.log("Button was clicked!");
};

button.onclick = clickButtonHandler; // not works anymore
button.onclick = clickButtonHandler2; // this function will execute
```

Instead, it is recommended that you use `addEventListener` as we did it throughout this course, because this allows you to add multiple event listeners to the same element and you also have a `removeEventListener` function or method which you can use to remove an event listener. For example:

```js
const button = document.querySelector("button");

const clickButtonHandler = () => {
  console.log("Button was clicked!");
};

button.addEventListener("click", clickButtonHandler);
```

Now with the most elegant way of doing this. As we said, we can remove the event listener with `removeEventListener`. For example:

```js
const button = document.getElementById("button");

const clickButtonHandler = () => {
  console.log("Button was clicked!");
};

button.addEventListener("click", clickButtonHandler);

const removeClickEvent = () => {
  button.removeEventListener("click", clickButtonHandler);
  console.log("Button event has removed!");
};

setTimeout(removeClickEvent, 3000);
```

- We get a button element
- We added the event listener for this element
- We set a timer (three seconds) for removing the event listener from button element

Consider:

```js
const button = document.getElementById("button");

button.addEventListener("click", () => {
  console.log("Cicked!");
});

setTimeout(() => {
  button.removeEventListener("click", () => {
    console.log("Cicked!");
  });
}, 3000);
```

It's the same function, it does the exact same thing, right? If you test it on browser, you wil see no event listener removed. The reason for that simply is that, **these anonymous functions look similar to us humans, but technically it's not the same function object**. This `button.addEventListener("click", () => { ..` creates a new function object and so does the second `button.addEventListener("click", () => { ..`! **So these are two totally different object**.

Instead we have to make sure we store that anonymous function in a constant which then holds the address of this function object. For example:

```js
const button = document.getElementById("button");

const clickButtonHandler = () => {
  console.log("Button was clicked!");
};

button.addEventListener("click", clickButtonHandler);

setTimeout(() => {
  button.removeEventListener("click", clickButtonHandler);
}, 3000);
```

Then, consider following example:

```js
const button = document.getElementById("button");

const clickButtonHandler = () => {
  console.log("Button was clicked!");
};

button.addEventListener("click", clickButtonHandler.bind(this));

setTimeout(() => {
  button.removeEventListener("click", clickButtonHandler.bind(this));
}, 3000);
```

You might again think well this is similar, **no it isn't**. This is not similar, `bind(this)` creates a new function object and therefore we create a new function object of these event listeners, so this also will not work.

You will have to store the bound function in a new constant like `boundFn`. For example:

```js
const button = document.getElementById("button");

const clickButtonHandler = () => {
  console.log("Button was clicked!");
};

const boundFn = clickButtonHandler.bind(this);

button.addEventListener("click", boundFn);

setTimeout(() => {
  button.removeEventListener("click", boundFn);
}, 3000);
```

That again we have the address of this function object. So we use the same function object and **this would work**. The other approach would not work.

## The `event` Object

Consider:

```js
const button = document.getElementById("button");

const clickButtonHandler = (event) => {
  console.log(event);
};

button.addEventListener("click", clickButtonHandler);

setTimeout(() => {
  button.removeEventListener("click", clickButtonHandler);
}, 3000);
/*
MouseEvent {isTrusted: true, screenX: 93, screenY: 582, clientX: 93, clientY: 446, …}
  altKey: false
  bubbles: true
  button: 0
  buttons: 0
  cancelBubble: false
  cancelable: true
  clientX: 93
  clientY: 446
  composed: true
  ctrlKey: false
  currentTarget: null
  defaultPrevented: false
  detail: 1
  eventPhase: 0
  fromElement: null
  isTrusted: true
  layerX: 93
  layerY: 838
  metaKey: false
  movementX: 0
  movementY: 0
  offsetX: 92
  offsetY: 0
  pageX: 93
  pageY: 838
  path: (5) [button#button, body, html, document, Window]
  relatedTarget: null
  returnValue: true
  screenX: 93
  screenY: 582
  shiftKey: false
  sourceCapabilities: InputDeviceCapabilities {firesTouchEvents: false}
  srcElement: button#button
  target: button#button
  timeStamp: 2617.870000000039
  toElement: button#button
  type: "click"
  view: Window {parent: Window, opener: null, top: Window, length: 0, frames: Window, …}
  which: 1
  x: 93
  y: 446
  __proto__: MouseEvent
*/
```

Every event has `target` property and `target` describes which target, which element in the end caused this event. So **where, in this case where you clicked on**.

Here is an event tree:

![evtree](https://o7planning.org/en/12321/images/37529913.png)

This `event` object is very very useful, for example:

```js
const buttons = document.querySelectorAll("button");

const clickButtonHandler = (event) => {
  event.target.disabled = true; // target: button
  console.log(event);
};

buttons.forEach((btn) => {
  btn.addEventListener("click", clickButtonHandler);
});
```

The buttons will be disabled when they're pressed. If we inspect these elements here, then we see they have the `disabled` attribute.

## Supported Event Types

We can also register other events, for example `mouseenter`. This event i triggered whenever our mouse or a cursor enters any element.

```js
const buttons = document.querySelectorAll("button");

const clickButtonHandler = (event) => {
  event.target.disabled = true;
  console.log(event);
};

buttons.forEach((btn) => {
  btn.addEventListener("mouseenter", clickButtonHandler);
});
```

> Let's look at `relatedTarget` property, this can be useful. This can help you understand where the mouse cursor is coming from.

Let's have fun with the `scroll` event and create a list which you can scroll infinitely:

```js
let curElementNumber = 0;

function scrollHandler() {
  const distanceToBottom = document.body.getBoundingClientRect().bottom;

  if (distanceToBottom < document.documentElement.clientHeight + 150) {
    const newDataElement = document.createElement("div");
    curElementNumber++;
    newDataElement.innerHTML = `<p>Element ${curElementNumber}</p>`;
    document.body.append(newDataElement);
  }
}

window.addEventListener("scroll", scrollHandler);
```

**Q**: What's happening here?

**Answer**:

- At the very bottom, we register the `scrollHandler` function as a handler for the `scroll` event on our `window` object.

- Inside that function, we first of all **measure the total distance** between our viewport (top left corner of what we currently see) and the end of the page (**not** just the end of our currently visible area) => Stored in `distanceToBottom`.

- For example, if our browser window has a height of `500px`, then `distanceToBottom` could be `684px`, assuming that we got some content we can scroll to.

- Next, we **compare the distance** to the bottom of our overall content (`distanceToBottom`) **to the window height + a certain threshold** (in this example `150px`). `document.documentElement.clientHeight` is preferable to `window.innerHeight` because it respects potential scroll bars.

- If we have **less than 150px to the end of our page content**, we make it into the if-block (where we append new data).

- Inside of the `if` statement, we then create a new `<div>` element and populate it with a `<p>` element which in turn outputs an incrementing counter value.

## `preventDefault()` Method

Consider:

```js
const button = document.querySelector("form");

button.addEventListener("submit", (event) => {
  event.preventDefault();
  console.log(event);
});
/*
SubmitEvent {isTrusted: true, submitter: button#title, type: "submit", target: form, currentTarget: form, …}
  bubbles: true
  cancelBubble: false
  cancelable: true
  composed: false
  currentTarget: null
  defaultPrevented: true
  eventPhase: 0
  isTrusted: true
  path: (5) [form, body, html, document, Window]
  returnValue: false
  srcElement: form
  submitter: button#title
  target: form
  timeStamp: 2540.234999999484
  type: "submit"
  __proto__: SubmitEvent
*/
```

If we do this, the page will not reload (refresh) after submitting a value to sever (or client). Because by default, the page will reload when we submit a value.

**Note**: `preventDefault()` is a very important method on the `event` object, which you can use to control what the browser does with that event.

## Bubbling and Capturing

Let's say we have a button in a `<div>` which is in a `<section>`:

```html
<section>
  <div>
    <button></button>
  </div>
</section>
```

Consider that we click that button here. Now what actually happens is that the browser runs through two phases where it checks for listeners to that event.

**First**, it runs through a phase which is called the **capturing** phase. **Second**, it runs through a phase which is called the **bubbling** phase.

The **capturing** phase goes from outside to inside. Now what does this mean?

It's important to understand that a `click` event on such a nested `<button>` here, cannot just be listened to with event listeners on the `<button>`. But for example, also with an event listener on that `<section>` and the browser during the capturing phase checks if you got a capturing event listener on the `<section>` registered which would then actually run its function before any event listeners registered on the `<button>`. Because it's from outside to inside in the capturing phase, and the `<section>` is **outside of the `<button>`**.

The bubbling phase on the other hand does the opposite; it goes from inside to outside. All event listeners you add with `addEventListener` are by default registered in that bubbling phase; which means if we have an event listener on the `<button>` and on the `<section>`, **the `<button>` event listener will runs first, the `<section>` event listener will runs second**.

Let's expand this article with an example:

```html
<!-- HTML -->
<section>
  <div>
    <button>Click me!</button>
  </div>
</section>
```

```js
// JavaScript
const button = document.querySelector("button");
const div = document.querySelector("div");

div.addEventListener("click", () => {
  console.log("CLICKED DIV");
});

button.addEventListener("click", () => {
  console.log("CLICKED BUTTON");
});
/*
CLICKED BUTTON
CLICKED DIV
*/
```

Now with that setup, if you click on the button here, you see both execute `button` and then `div`. So it executes from inside to outside, because as we mentioned, by default all event listeners are registered in the bubbling phase; which means that capturing phase which runs first is totally ignored.

We can switch to the capturing phase by adding an extra third argument on the `addEventListener` (event listeners). The default value is `false`, we can switch it to `true` in the third argument of event listeners. For example:

```js
const button = document.querySelector("button");
const div = document.querySelector("div");

div.addEventListener("click", () => {
  console.log("CLICKED DIV");
}, true);

button.addEventListener("click", () => {
  console.log("CLICKED BUTTON");
});
/*
CLICKED DIV
CLICKED BUTTON
*/
```

Let's say we do have an event listener on the `div` element. But we only want to react to clicks on the `div` here, not to clicks on a `button` in the `div`.

If we want to make sure that `button` clicks don't trigger the `div` click listener, for example `button` doesn't propagate anymore, we can call `event.stopPropagation()`.

```js
const button = document.querySelector("button");
const div = document.querySelector("div");

div.addEventListener("click", () => {
  console.log("CLICKED DIV");
});

button.addEventListener("click", (event) => {
  event.stopPropagation();
  console.log("CLICKED BUTTON");
});
```

That's not the same as `preventDefault()` method.

We also have `event.stopImmediatePropagation()`, this is useful if we have multiple event listeners on the same element. So if we had more event listeners on the `button`, then after the **first event listener**, the other `button` listeners (the other listeners on the same element) wouldn't run anymore.

With just `stopPropagation()`, all `button` event listeners would execute and only ancestor element click listeners would not execute. That the difference here.
