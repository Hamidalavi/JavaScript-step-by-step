# Meta-programming

In this course, you will learn about:

- Symbols
- Iterators & Generators
- Reflect API
- Proxy API

## Symbol

Symbols like boolean, string, number and so on, are **primitive** value. For example:

```js
const uid = Symbol();
console.log(uid, typeof uid); // Symbol() "symbol"
```

Let's see the example:

```js
const uid = Symbol("uid");

const user = {
  [uid]: "p1",
  name: "Hamid",
  age: 23
};

console.log(user); // { name: 'Hamid', age: 23, [Symbol(uid)]: 'p1' }
```

Or

```js
const uid = Symbol();

const user = {
  [uid]: "p1",
  name: "Hamid",
  age: 23
};

console.log(user); // { name: 'Hamid', age: 23, [Symbol()]: 'p1' }
```

**Important**: Symbols are not equal with together, for example:

```js
console.log(Symbol("uid") === Symbol("uid")); // false
```

It's like the `NaN` value.

Let's look at this example:

```js
const uid = Symbol("uid");

const user = {
  [uid]: "p1",
  name: "Hamid",
  age: 23
};

user[uid] = "p2";
console.log(user); // { name: 'Hamid', age: 23, [Symbol(uid)]: 'p2' }
```

As you can see, we can change the Symbol's value.

If we convert the `user` object to `string`, we will get:

```js
const uid = Symbol("uid");

const user = {
  [uid]: "p1",
  name: "Hamid",
  age: 23
};

user[uid] = "p2";
console.log(user.toString()); // [object Object]
```

Because the `toString()` method called on any object just print `[object Object]` (objects have these prototype and built-in method). We can add a special `Symbol` to the `user` object with a dynamic property assignment (i.e. `[]`) syntax. We can also change the output with the built-in `Symbol.toStringTag`, for example:

```js
// without `toStringTag`
const uid = Symbol("uid");

const user = {
  [uid]: "p1",
  name: "Hamid",
  age: 23,
};

user[uid] = "p2";
console.log(user.toString()); // "[object Object]"


// with `toStringTag`
const uid = Symbol("uid");

const user = {
  [uid]: "p1",
  name: "Hamid",
  age: 23,
  [Symbol.toStringTag]: "User"
};

user[uid] = "p2";
console.log(user.toString()); // "[object User]"
```

## Iterator

An iterator is an object in the end which has a next method. Consider:

```js
const company = {
  employees: ["Hamid", "Hamed", "Ali", "Reza", "Majid", "Mehrdad", "Morteza"]
};
```

We make it iterable or we turn it into an iterator by adding a `next()` method. Consider:

```js
const company = { // step 1
  currentEmployee: 0,
  employees: ["Hamid", "Hamed", "Ali", "Reza", "Majid", "Mehrdad", "Morteza"],
  next() { // step 2
    if (this.currentEmployee >= this.employees.length) { // step 5
      return { value: this.currentEmployee, done: true };
    }
    const returnedValue = { // step 3 and 4
      value: this.employees[this.currentEmployee],
      done: false
    };
    this.currentEmployee++;
    return returnedValue;
  }
};

console.log(company.next()); // { value: 'Hamid', done: false }
console.log(company.next()); // { value: 'Hamed', done: false }
console.log(company.next()); // { value: 'Ali', done: false }
console.log(company.next()); // { value: 'Reza', done: false }
console.log(company.next()); // { value: 'Majid', done: false }
console.log(company.next()); // { value: 'Mehrdad', done: false }
console.log(company.next()); // { value: 'Morteza', done: false }
console.log(company.next()); // { value: 7, done: true }
```

Do you understand it? Well, it's a new thing for you. Let's describe it:

1. We created a simple object with `currentEmployee` and `employees` properties.

2. We made it iterable by adding a `next()` method.

3. In `next()` method, we have two configuration, **one** is `value` and **two** is `done` property.

4. `value` gets a value (property) from object (i.e. `this.employees[this.currentEmployee]`) and `done` is for the stop or start of the iteration.
   - `true`: stop iterating
   - `false`: start iterating

5. We stopped the iteration with `if` statement (done: `true`).

We can dynamically loop them with `while` loop:

```js
const company = {
  currentEmployee: 0,
  employees: ["Hamid", "Hamed", "Ali", "Reza", "Majid", "Mehrdad", "Morteza"],
  next() {
    if (this.currentEmployee >= this.employees.length) {
      return { value: this.currentEmployee, done: true };
    }
    const returnedValue = {
      value: this.employees[this.currentEmployee],
      done: false
    };
    this.currentEmployee++;
    return returnedValue;
  }
};

let employee = company.next();

while (!employee.done) {
  console.log(employee.value);
  employee = company.next();
}
/*
"Hamid"
"Hamed"
"Ali"
"Reza"
"Majid"
"Mehrdad"
"Morteza"
 */
```

**Note**: This would be one example how you can use your own iterator. `company`, which has this `next()` method which in turn allows you to have your own looping logic for whichever filed or whichever logic related to this `company` object you might have. That means you don't have to loop the entire `company` object.

## Generator

We can't use `for..of` loop in this example, for example:

```js
const company = {
  currentEmployee: 0,
  employees: ["Hamid", "Hamed", "Ali", "Reza", "Majid", "Mehrdad", "Morteza"],
  next() {
    if (this.currentEmployee >= this.employees.length) {
      return { value: this.currentEmployee, done: true };
    }
    const returnedValue = {
      value: this.employees[this.currentEmployee],
      done: false
    };
    this.currentEmployee++;
    return returnedValue;
  }
};

let employee = company.next();

for (employee of company) {
  console.log(employee.value); // TypeError: company is not iterable
}
```

We can make this iterable with **generator**. Consider:

```js
const company = {
  currentEmployee: 0,
  employees: ["Hamid", "Hamed", "Ali", "Reza", "Majid", "Mehrdad", "Morteza"],
  next() {
    if (this.currentEmployee >= this.employees.length) {
      return { value: this.currentEmployee, done: true };
    }
    const returnedValue = {
      value: this.employees[this.currentEmployee],
      done: false
    };
    this.currentEmployee++;
    return returnedValue;
  },

  [Symbol.iterator]: function* employeeGenerator() {
    let employee = company.next();

    for (employee of company) {
      console.log(employee.value);
    }
  }
};
```

Here we used special `Symbol.iterator` for make this object iterable.

We can write our looping logic inside of this generator. We can move our `while` loop logic here from buttom into our `employeeGenerator` generator.

**Note**: Every function that have a `*` symbol, that function is a generator.

So instead of using `console.log(employee.value);`, we must use `yield` keyword (i.e. `yield employee.value`). `yield` in the end, generates a new object; `employeeGenerator` function when it's called generates a new object which has a `next()` method on its own. That means we can remove our custom `next()` method:

```js
const company = {
  currentEmployee: 0,
  employees: ["Hamid", "Hamed", "Ali", "Reza", "Majid", "Mehrdad", "Morteza"],
  next() {
    if (this.currentEmployee >= this.employees.length) {
      return { value: this.currentEmployee, done: true };
    }
    const returnedValue = {
      value: this.employees[this.currentEmployee],
      done: false
    };
    this.currentEmployee++;
    return returnedValue;
  },

  [Symbol.iterator]: function* employeeGenerator() {
    let employee = company.next();

    for (employee of company) {
      yield employee.value;
      console.log(employee.value);
    }
  }
}; // no output (just for showing `yield` keyword)
```

**Note**: `yield` basically is the point where **JavaScript** saves the current state of execution and the next time we call the `next()` method on the created iterator, it will continue from that point.

So we can remove the `next()` method. We can also remove the `[Symbol.iterator]`, because generators are iterable:

```js
const company = {
  employees: ["Hamid", "Hamed", "Ali", "Reza", "Majid", "Mehrdad", "Morteza"],
  getEmployee: function* employeeGenerator() {
    let currentEmployee = 0;
    while (currentEmployee < this.employees.length) {
      yield this.employees[currentEmployee];
    }
  }
};

console.log(company.getEmployee().next()); // { value: 'Hamid', done: false }
console.log(company.getEmployee().next()); // { value: 'Hamid', done: false }
console.log(company.getEmployee().next()); // { value: 'Hamid', done: false }
... // { value: 'Hamid', done: false }
```

As you can see, it's easy to understand and easy to use. But look at the result, all of the are `{ value: 'Hamid', done: false }`. The reason for that is that whenever we call `getEmployee`, we generate a new iterator. So instead what we should do, is we should create a new constant and call `company.getEmployee()` once and then use that same object all the time.

**Note**: Make sure that in your generator logic, you also need increment `currentEmployee` by `1`:

```js
const company = {
  employees: ["Hamid", "Hamed", "Ali", "Reza", "Majid", "Mehrdad", "Morteza"],
  getEmployee: function* employeeGenerator() {
    let currentEmployee = 0;
    while (currentEmployee < this.employees.length) {
      yield this.employees[currentEmployee];
      currentEmployee++;
    }
  }
};

let it = company.getEmployee();

console.log(it.next()); // { value: 'Hamid', done: false }
console.log(it.next()); // { value: 'Hamed', done: false }
console.log(it.next()); // { value: 'Ali', done: false }
console.log(it.next()); // { value: 'Reza', done: false }
console.log(it.next()); // { value: 'Majid', done: false }
console.log(it.next()); // { value: 'Mehrdad', done: false }
console.log(it.next()); // { value: 'Morteza', done: false }
console.log(it.next()); // { value: undefined, done: true }
```

**Q**: Why is that useful?

**Answer**: We don't have to write our own `next()` method as we did before, we just have this short logic here and `yield` is the special thing here together with the `*` (i.e. `function*`). This allows **JavaScript** to build such an iterator behind the scenes; and whenever `yield` is encountered, this basically is the point where **JavaScript** saves the current state of execution and the next time we call the `next()` method on the created iterator, it will continue from that point on, and therefore then give us the next value and the next value and the ... .

In the end, we can use the special `[Symbol.iterator]` instead of `getEmployee` and use `for..of` loop:

```js
const company = {
  employees: ["Hamid", "Hamed", "Ali", "Reza", "Majid", "Mehrdad", "Morteza"],
  [Symbol.iterator]: function* employeeGenerator() {
    let currentEmployee = 0;
    while (currentEmployee < this.employees.length) {
      yield this.employees[currentEmployee];
      currentEmployee++;
    }
  }
};

for (const employee of company) {
  console.log(employee);
}
/*
"Hamid"
"Hamed"
"Ali"
"Reza"
"Majid"
"Mehrdad"
"Morteza"
 */
```

Because what a `for..of` loop does, is it goes to `company` object we're looping through and it searches for this `[Symbol.iterator]` thing there. Then it executes the function which it finds there, which should be a generator. So that in the end, this returns an iterator.

**Note**: If you execute that generator function, you get an iterator as you learned before; and then **JavaScript** executes the `next()` method on this iterator it got, for you as long as `done` is `false` (not `true`) and extracts the thing in the `value` property into this `const` (i.e. `const employee of company`) which you can then use and consume inside of your `for..of` loop body (i.e. `console.log(employee);`).

We can also use spread operator, because the `...` spread operator also behind the scenes looks for `[Symbol.iterator]`:

```js
const company = {
  employees: ["Hamid", "Hamed", "Ali", "Reza", "Majid", "Mehrdad", "Morteza"],
  [Symbol.iterator]: function* employeeGenerator() {
    let currentEmployee = 0;
    while (currentEmployee < this.employees.length) {
      yield this.employees[currentEmployee];
      currentEmployee++;
    }
  }
};

for (const employee of company) {
  console.log(employee);
}
/*
"Hamid"
"Hamed"
"Ali"
"Reza"
"Majid"
"Mehrdad"
"Morteza"
 */

console.log([...company]);
/*
(7) ["Hamid", "Hamed", "Ali", "Reza", "Majid", "Mehrdad", "Morteza"]
  0: "Hamid"
  1: "Hamed"
  2: "Ali"
  3: "Reza"
  4: "Majid"
  5: "Mehrdad"
  6: "Morteza"
  length: 7
  __proto__: Array(0)
 */
```

It goes through all the values and adds them as elements here in this new array (i.e. `[...company]`).

**Summary**: We can write our own `for..of` loopable objects with the help of this special well-known `[Symbol.iterator]` and generator function.
