# More About Classes & Objects - Constructor Functions & Prototypes

In this course, you learn about:

- What Happens Behind The Scenes of Classes and Objects
- Constructor Functions (Without Classes)
- Prototype & Prototypical Inheritance

## Constructor Functions vs Classes

Consider:

```js
class Person {
  name = "Hamid";
  constructor() {
    this.age = 23;
  }

  greet() {
    console.log(`Hi, I am ${this.name} and I am ${this.age} years old`);
  }
}

const person = new Person();
person.greet(); // Hi, I am Hamid and I am 23 years old
```

You learend how to use fields and methods and constructors and etc. before. This is a **class**.

But what is `constructor function`? It caught your eye a lot and you worked with it a lot before; see the following snippet:

```js
function Person() {
  this.name = "Hamid";
  this.age = 23;
  this.greet = function () {
    console.log(`Hi, I am ${this.name} and I am ${this.age} years old`);
  };
}

const person = new Person();
person.greet(); // Hi, I am Hamid and I am 23 years old
```

As you can see, we use `function` keyword. It looks like a function. This is a **constructor function**. If you see the previous snippet, you know how easy it is (**constructor functions**).

What happens when we delete the `new` keyword? Let's do this:

```js
function Person() {
  this.name = "Hamid";
  this.age = 23;
  this.greet = function () {
    console.log(`Hi, I am ${this.name} and I am ${this.age} years old`);
  };
}

const person = Person();
person.greet(); // TypeError: Cannot read property 'greet' of undefined
```

Because this just calling (executing) the function (class), not `return` any method (field and etc.). When we use the `new` keyword in front of `className`, behind the scences, this class create an empty object named `this`, then it adds all properties to this empty object and then it return `this`. For example:

```js
function Person() {
  this = {...};
  return this;
}
```

**constructor function**: A function which we can call with `new`.

Different of constructor functions and classes:

|Constructor Functions|Classes|
|:-:|:-:|
|Blueprint for Objects|Blueprint for Objects|
|Properties & Methods|Properties & Methods|
|Can be called with `new`|Must be called with `new`|
|All properties and methods are enumerable|Methods are non-enumerable by default|
|Not in strict mode by default|Always in strict mode|

## Prototypes

Every constructor function we build, has a special prototype property which is not added to the objects we create based on it, because it's not part of the function body. But property of that function object (functions are objects), that prototype is there by default. We can edit it, something we will do and it is then automatically assigned as a prorotype to the object which is created when we instantiate that constructor function.

Why does every object have a ptototype?

**Note**: Prototype Objects == **Fallback Objects**.

Let's see the following example:

```js
class Person {
  name;

  greet() {
    console.log("Yo guys and girls");
  }
}

const person = new Person();
person.greet(); // "Yo guys and girls"
```

Let's say we have a `person` object which has a `name` property and a `greet` method, then we have some code which calls `person.sayHello()`. Now clearly there is no `sayHello` method in this `person` object.

As we mentioned before, every object in **JavaScript** has a prototype and a prototype is bacically a connected object which is used as a **fallback object**.

This is the connected prototype to the `person` object and this prototype object might have a `sayHello` method; and if **JavaScript** tries to access a certain method or property and doesn't find it on an object, it automatically looks at the prototype object and looks for the property there. If it doesn't find it there, it looks at the prototype of the prototype (chained prototype), all the way until it reaches the end of that chain and didn't find that property or method anywhere; and in that case for a property, it would return `undefined` and for a method, it would `throw` an error.

**Note**: **JavaScript** automatically looks into the prototype of the object and searches for the property or method there. Consider:

```js
class Person {
  name = "Hamid";
  age = 23;

  greet() {
    console.log(`Hi, I am ${this.name} and I am ${this.age} years old`);
  }
}

const person = new Person();

console.log(person.toString()); // "[object Object]"

console.log(person);
/*
Person {name: "Hamid", age: 23}
  age: 23
  name: "Hamid"
  __proto__: Object
*/
```

See the last line of above code, `__proto__`. That's a special property, hence the strange name. It's not really a property you should use to assign a value to though, it would work but not really recommended. But it shows us what this so-called prototype of this object is.

In above example, if we don't find the `toString` method in this object itself, **JavaScript** will go to that prototype, So to this object and look into that (`__proto__`). If we expand `__proto__`, we dont see anything, for example:

```js
/*
__proto__:
  constructor: class Person
  greet: ƒ greet()
  __proto__: Object
  */
```

We see another object which has a constructor method (that's a `function`, so it's a constructor method). This also has a prototype and then **JavaScript** goes to that prototype, and here we have a more complex object and there for example, we see the `toString` method and a couple of other methods.

```js
/*
__proto__:
  constructor: class Person
  greet: ƒ greet()
  __proto__:
    constructor: ƒ Object()
    hasOwnProperty: ƒ hasOwnProperty()
    isPrototypeOf: ƒ isPrototypeOf()
    propertyIsEnumerable: ƒ propertyIsEnumerable()
    toLocaleString: ƒ toLocaleString()
    toString: ƒ toString() --------- this line we see `toString()` method
    valueOf: ƒ valueOf()
    __defineGetter__: ƒ __defineGetter__()
    __defineSetter__: ƒ __defineSetter__()
    __lookupGetter__: ƒ __lookupGetter__()
    __lookupSetter__: ƒ __lookupSetter__()
    get __proto__: ƒ __proto__()
    set __proto__: ƒ __proto__()
*/
```
