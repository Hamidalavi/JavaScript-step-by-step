# NodeJS Introduction

In this course, you will learn about:

- What is Exactly Node.js
- Writing Node.js Code
- Using Express.js
- Database

## about Node.js

As you learned, **JavaScript** is a hosted language. That means **JavaScript** itself can be implemented in different environments.

**Node.js** is essentially the extracted V8 engine Chrome offers, enriched by extra APIs. So its that engine you know from the browser; but basically instead of the browser APIs, it has access to other APIs and it runs outside of the browser. This is **Node.js**. We dont work with DOM and storage in this course.

You can download **Node.js** app in <https://nodejs.org/en/> website. If you are using other OS, use these commands:

- `sudo apt-get install nodejs` for Ubuntu
- `pkg install nodejs` for Android (via termux app)
- `pacman -Syu nodejs npm` for Arch Linux
- `pkg install node` for FreeBSD
  - Or compile it on your own using `ports`: `cd /usr/ports/www/node && make install`
- `emerge nodejs` for Gentoo
- `yum install nodejs14` for IBM i

Other installations are in [this](https://nodejs.org/en/download/package-manager/) link.

## Writing Node.js Code

Once you download and install **Node.js**, you can use it everywhere (outside of browser) or you can use it in terminal or command prompt (cmd) with `node` (or `node.exe`) command. As you know, **Node.js** is very similar to **JavaScript**.

We can execute some code with `node <file-name>.js` command; let's make an `app.js` file and write some code:

```js
console.log("Hamid");

node app.js
// "Hamid"
```

If you remember, we worked with `webpack`. Most of them are compatible with **Node.js** and browser doesn't know them and they of course do not run inside of a browser (e.g. `module.exports` or `require...` and so on). Behind the scenes, `webpack` uses **Node.js** to read in our file.

We said **browser doesn't know them**, that means:

```js
document.getElementById("my-id");

node app.js
// ReferenceError: document is not defined
```

## Work with File System

As you know before, you can use **JavaScript** in Browser-side and Other-side (e.g. server-side).

> in browser-side:

- **JavaScript** was invented to create more dynamic websites by executing in the browser! That's the origin of **JavaScript**.

- **JavaScript** can manipulate the HTML code, CSS, send background Http requests and allows interaction with web page and browser APIs (e.g. get user location) and much more.

- **JavaScript** **can't** access the local filesystem (interact with the operating system etc.).

> in other-side (e.g. server-side like Node.js):

- Googleâ€™s **JavaScript** Engine (V8) extracted to run **JavaScript** anywhere (called **Node.js**).

- **Node.js** can be executed on any machine and is therefore often used to build web backends (server-side **JavaScript**).

- **Node.js** **can** access the local filesystem, interact with the operating system etc. It **can't** manipulate HTML or CSS.

We access the local filesystem or interact with the operating system with `fs`, for example:

```js
const filesystem = require("fs");

or

import filesystem from "fs"; // need module type (ES6+)
```

We can write a file with `filesystem.writeFile()`, this method takes three parameters, the **first one** is the file name in the current path, the **second one** is for data (data includes everythings) and the **third one** is a callback function for error message:

```js
const filesystem = require("fs");

filesystem.writeFile("test.md", "# Hello Hamid", (err) => {
  if (err) {
    console.log(err);
  } else {
      console.log("wrote to file!")
  }
});

node app.js
"wrote to file!" // test.md file created
```

We can read a file with `filesystem.readFile()` method. We use two paramters in this method, the **first one** is the file name, the **second one** is a callback function that takes two arguments; **first** for error and **second** for file data:

```js
const filesystem = require("fs");

filesystem.readFile("test.md", (err, data) => {
  if (err) {
    console.log(err);
    return;
  }
  console.log(data);
});

node app.js
"# Hello Hamid"
```

We convert the data to string to being readable for us. If we don't convert it, it will be `<Buffer 23 20 48 65 6c 6c 6f 20 48 61 6d 69 64>` which is coming from parsing the file.

## Http

First of all we need to import `http` module:

```js
const http = require("http");
```

It's a module that allows us to work with HttpRequests. If we want to create a sever (local web server), we need to use `createServer()` method:

```js
http.createServer();
```

This method requires one important argument for that, **a request listener**. This is a function which in the end triggers for every incoming request. This request listener function takes two arguments which are passed in automatically by **Node.js**; that's a **request** object and a **response** object:

```js
http.createServer((request, response) => {});
```

> response object

To write some data to the response, we need to use `write()` method:

```js
const http = require("http");

http.createServer((request, response) => {
  response.write("Hello there!");
});
```

We also need to pass the `end()` method for send the response. So `end()` basically tells **Node.js** "we're done adding data to the response, you can close it and send it back":

```js
const http = require("http");

http.createServer((request, response) => {
  response.write("Hello there!");
  response.end();
});
```

This is a very very simple web sever. With the server created, we need to do one more thing though. We need to call `listen()` on it.

```js
const http = require("http");

const server = http.createServer((request, response) => {
  response.write("Hello there!");
  response.end();
});

server.listen();
```

`listen()` is required to then actually start the server. In this case:

- `createServer()` for creating a server.
- `listen()` listens to incoming requests.

If we want to work with our web server, we need to pass a port into `listen()` method:

```js
const http = require("http");

const server = http.createServer((request, response) => {
  response.write("Hello there!");
  response.end();
});

server.listen(3000);
```

Now you see the content (i.e. `Hello there!`) in `http://localhost:3000/` or `localhost:3000`.

We can also use html content in there:

```js
const http = require("http");

const server = http.createServer((request, response) => {
  response.write("<h1>Hamid</h1>");
  response.end();
});

server.listen(3000);
```

It looks OK, but we don't have any headers for this page, we can add a header with `setHeader()` method:

```js
const http = require("http");

const server = http.createServer((request, response) => {
  response.setHeader("Content-Type", "text/plain");
  response.write("<h1>Hamid</h1>");
  response.end();
});

server.listen(3000);
```

As you can see, this method takes two arguments where the first argument is the header identifier and the second argument is the value for that header. In this example, we wrote `"Content-Type"` (we worked with that before on client-side **JavaScript**).

You test this code, right? do you See the problem?

Yes, this is a plain text that is just `<h1>Hamid</h1>` (don't parse it as HTML). We can change the value to `text/html` to fix this problem:

```js
const http = require("http");

const server = http.createServer((request, response) => {
  response.setHeader("Content-Type", "text/html");
  response.write("<h1>Hamid</h1>");
  response.end();
});

server.listen(3000);
```

**Warning**: If you don't set headers for your page, maybe some modern browsers know that (i.e. automatically convert to h1 `Hamid`), but other browsers don't support that and your web content may break or being fragmentary for this reason. If you set headers for your page, all browsers will then do that.

> request object

We talk about request a value, first of all, we need to add a basic html form:

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <form method="POST" action="/">
        <input type="text" name="username">
        <button type="submit">Send!</button>
    </form>
</body>

</html>
```

Then we read this file with our knowledge (instead of writing this code manually):

```js
const fs = require("fs");
const http = require("http");

const server = http.createServer((request, response) => {
  response.setHeader("Content-Type", "text/html");
  fs.readFile("test.html", (err, data) => {
    response.write(data);
    response.end();
  });
});

server.listen(3000);
```

If we want to see behind the scenes of request object, we need to:

```js
const fs = require("fs");
const http = require("http");

const server = http.createServer((request, response) => {
  console.log(request.method, request.url);
  response.setHeader("Content-Type", "text/html");
  fs.readFile("test.html", (err, data) => {
    if (err) throw err;
    response.write(data);
    response.end();
  });
});

server.listen(3000);
```

We added `console.log(request.method, request.url);` to see what happens in there. If we reload the page, we see the output that is `GET /`, and if we click on a button, we will see `POST /`; because we send a request.

Thereafter, if we type `Hamid` in input and click on the `Send` button, it will be changed to `username=Hamid`. We can send a request with a strange way:

```js
const fs = require("fs");
const http = require("http");

const server = http.createServer((request, response) => {
  let body = [];
  request.on("data", (chunk) => {
    body.push(chunk);
  });
  request.on("end", () => {
    body = Buffer.concat(body).toString();
    console.log(body);
  });
  response.setHeader("Content-Type", "text/html");
  fs.readFile("test.html", (err, data) => {
    if (err) throw err;
    response.write(data);
    response.end();
  });
});

server.listen(3000);
```

We can also show the real-time `username`:

```js
const fs = require("fs");
const http = require("http");

const server = http.createServer((request, response) => {
  let body = [];
  request.on("data", (chunk) => {
    body.push(chunk);
  });
  request.on("end", () => {
    body = Buffer.concat(body).toString();
    let userName = "Unknown User";
    if (body) {
      userName = body.split("=")[1];
    }

    fs.readFile("test.html", (err, data) => {
      if (err) throw err;
      response.write(`<h1>Hello ${userName}</h1> ${data}`);
      response.end();
    });
  });
  response.setHeader("Content-Type", "text/html");
});

server.listen(3000);
```

We put the `fs.readFile` and `response.write()` and `response.end()` into the `request.do()` method. Because they run asynchrony.
