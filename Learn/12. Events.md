# Events - Mouse Click, Hover and son on

In this course, you learn about:

- A Closer Look at Events
- Event Propagation
- Drag & Drop

## Event Introduction

We can run code upon certain events. In browser-side, we use `addEventListener` method and in server-side (like NodeJs), we use `on` method.

- Browser-side: `addEventListener('...', event => ...)`
- Server-side: `on('...', event => ...)`

It's important to understand that we have different kinds of events we can listen to. **a click on a button or a click on anything else, a right click or a double click, hovering over something or moving the mouse button away from something**; these are all different kinds of events.

**Note**: Events typically transport data.

We have an `Event` constructor function, a core event object you could say with some core functionalities which all events share.

You learned how you can add an event listener to a button. You first of all select the button, for example with `querySelector()` or with `getElementById()` and then you can use the `addEventListener` method which exists on any DOM node basically to attach an event to it.

Let's show you two other ways of adding events.

> **One** is a way that is pretty old and which you shouldn't use anymore, still for completeness sake, we want to show it to you.

You can go right to the HTML node in your HTML code and there, you can add an attribute. For example, `onclick`:

```html
<button onclick="alert('Hello!');">Click on me</button>
```

This is not an arbitrary name chosen by us. There are various `on` attributes for different events that this element supports. So, if we click on that button, the output result will be `"Hello!"` (in `alert()` method (function)).

**Warning**: Don't mix HTML and HTML attributes and **JavaScript** code, it's absolutely not a recommended practice. You should register events in your **JavaScript** file instead.

> **Two**, we also have another way of adding an event. It's pretty close to what we did here in HTML. **Just this time in JavaScript**.

```js
const button = document.querySelector("button");

button.onclick = function () {
  alert("Hello!");
};
```

Or we can use arrow function for this way, for example:

```js
const button = document.querySelector("button");

const clickButtonHandler = () => {
  alert("Hello!");
};

button.onclick = clickButtonHandler;
```

**Note**: Don't execute this function right away, instead as with the event listener, point at it.

**Warning**: We can't use `button.onclick ..` twice. The reason for that is that we simply override the value which is stored in this property. So this (value or function) is not added or appended as a listener, it's simply overriding the old listener. For example:

```js
const button = document.querySelector("button");

const clickButtonHandler = () => {
  alert("Hello!");
};

const clickButtonHandler2 = () => {
  console.log("Button was clicked!");
};

button.onclick = clickButtonHandler; // not works anymore
button.onclick = clickButtonHandler2; // this function will execute
```

Instead, it is recommended that you use `addEventListener` as we did it throughout this course, because this allows you to add multiple event listeners to the same element and you also have a `removeEventListener` function or method which you can use to remove an event listener. For example:

```js
const button = document.querySelector("button");

const clickButtonHandler = () => {
  console.log("Button was clicked!");
};

button.addEventListener("click", clickButtonHandler);
```

Now with the most elegant way of doing this. As we said, we can remove the event listener with `removeEventListener`. For example:

```js
const button = document.getElementById("button");

const clickButtonHandler = () => {
  console.log("Button was clicked!");
};

button.addEventListener("click", clickButtonHandler);

const removeClickEvent = () => {
  button.removeEventListener("click", clickButtonHandler);
  console.log("Button event has removed!");
};

setTimeout(removeClickEvent, 3000);
```

- We get a button element
- We added the event listener for this element
- We set a timer (three seconds) for removing the event listener from button element

Consider:

```js
const button = document.getElementById("button");

button.addEventListener("click", () => {
  console.log("Cicked!");
});

setTimeout(() => {
  button.removeEventListener("click", () => {
    console.log("Cicked!");
  });
}, 3000);
```

It's the same function, it does the exact same thing, right? If you test it on browser, you wil see no event listener removed. The reason for that simply is that, **these anonymous functions look similar to us humans, but technically it's not the same function object**. This `button.addEventListener("click", () => { ..` creates a new function object and so does the second `button.addEventListener("click", () => { ..`! **So these are two totally different object**.

Instead we have to make sure we store that anonymous function in a constant which then holds the address of this function object. For example:

```js
const button = document.getElementById("button");

const clickButtonHandler = () => {
  console.log("Button was clicked!");
};

button.addEventListener("click", clickButtonHandler);

setTimeout(() => {
  button.removeEventListener("click", clickButtonHandler);
}, 3000);
```

Then, consider following example:

```js
const button = document.getElementById("button");

const clickButtonHandler = () => {
  console.log("Button was clicked!");
};

button.addEventListener("click", clickButtonHandler.bind(this));

setTimeout(() => {
  button.removeEventListener("click", clickButtonHandler.bind(this));
}, 3000);
```

You might again think well this is similar, **no it isn't**. This is not similar, `bind(this)` creates a new function object and therefore we create a new function object of these event listeners, so this also will not work.

You will have to store the bound function in a new constant like `boundFn`. For example:

```js
const button = document.getElementById("button");

const clickButtonHandler = () => {
  console.log("Button was clicked!");
};

const boundFn = clickButtonHandler.bind(this);

button.addEventListener("click", boundFn);

setTimeout(() => {
  button.removeEventListener("click", boundFn);
}, 3000);
```

That again we have the address of this function object. So we use the same function object and **this would work**. The other approach would not work.

## The `event` Object

Consider:

```js
const button = document.getElementById("button");

const clickButtonHandler = (event) => {
  console.log(event);
};

button.addEventListener("click", clickButtonHandler);

setTimeout(() => {
  button.removeEventListener("click", clickButtonHandler);
}, 3000);
/*
MouseEvent {isTrusted: true, screenX: 93, screenY: 582, clientX: 93, clientY: 446, …}
  altKey: false
  bubbles: true
  button: 0
  buttons: 0
  cancelBubble: false
  cancelable: true
  clientX: 93
  clientY: 446
  composed: true
  ctrlKey: false
  currentTarget: null
  defaultPrevented: false
  detail: 1
  eventPhase: 0
  fromElement: null
  isTrusted: true
  layerX: 93
  layerY: 838
  metaKey: false
  movementX: 0
  movementY: 0
  offsetX: 92
  offsetY: 0
  pageX: 93
  pageY: 838
  path: (5) [button#button, body, html, document, Window]
  relatedTarget: null
  returnValue: true
  screenX: 93
  screenY: 582
  shiftKey: false
  sourceCapabilities: InputDeviceCapabilities {firesTouchEvents: false}
  srcElement: button#button
  target: button#button
  timeStamp: 2617.870000000039
  toElement: button#button
  type: "click"
  view: Window {parent: Window, opener: null, top: Window, length: 0, frames: Window, …}
  which: 1
  x: 93
  y: 446
  __proto__: MouseEvent
*/
```

Every event has `target` property and `target` describes which target, which element in the end caused this event. So **where, in this case where you clicked on**.

This `event` object is very very useful, for example:

```js
const buttons = document.querySelectorAll("button");

const clickButtonHandler = (event) => {
  event.target.disabled = true;
  console.log(event);
};

buttons.forEach((btn) => {
  addEventListener("click", clickButtonHandler);
});
```

The buttons will be disabled when they're pressed. If we inspect these elements here, then we see they have the `disabled` attribute.
