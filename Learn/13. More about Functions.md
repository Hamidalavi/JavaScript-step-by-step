# More about Functions

In this course, you learn about:

- Pure Functions & Side Effects
- Factory Functions
- Closures & Scope Revisited
- Recursion

## Pure and Impure Functions

A pure function is a function which for some given input. For some given arguments, always produces the same output (if we reload the page) and it also does not trigger any side effects; which means it does not change anything outside of the function. For example:

```js
function add(num1, num2) {
  return num1 + num2;
}

console.log(add(15, 8)); // 23
```

This is a perfect example for a pure function. It does not change anything outside of function and it always produces the same result for the same outputs.

We also have a impure function that if we call this function, we get the different results there every time we reload the page. For example:

```js
function add(num) {
  return num + Math.random();
}

console.log(add(23)); // 23.????????
```

## Side Effeccts

Let's declare a variable and create a function:

```js
let previousResult = 0

function add(num1, num2) {
  const sum = num1 + num2;
  previousResult = sum;
  return sum;
}
```

This function here would not be pure, because the side effect is `previousResult = sum`. We change a variable that is defined outside of the function (i.e. this function changes something).

Another example for a function with a side effect would be a function that changes an object or an array (change the address) that we pass into it. For example:

```js
const hobbies = ["programming", "gaming"];

function printHobbies(hob) {
  hob.push("Reading");

  console.log(hob);
}

printHobbies(hobbies); // [ 'programming', 'gaming', 'Reading' ]
```

**Note**: You should aim for more pure functions and less impure functions that might introduce side effects.

## Factory Functions

Factory function is a function that produces another function. Consider:

```js
function createTaxCalculator(amount, tax) {
  return amount * tax;
}

console.log(createTaxCalculator(100, 0.19)); // 19
```

We can have functions in a function, fo example:

```js
function createTaxCalculator(tax) {
  function calculateTax(amount) {
    return amount * tax;
  }
  return calculateTax;
}

const vatAmount = createTaxCalculator(0.19);
const incomeTax = createTaxCalculator(0.25);

console.log(vatAmount(100)); // 19
console.log(incomeTax(200)); // 50
```

## Closures - Lexical Scope

Every function in **JavaScript** is a closure. If we create a variable in function (or get a parameter), it's only usable inside of that function, but not outside of it. On the other hand, global variables or constants which are created outside of functions can be used inside of the function. That's something you already knew.

If we have a function in a function, that inner function can use all the variables or parameters of the outer function and all variables and constants that are defined globally.

The outer function cannot access the inner functions, specific constants and variables. For example, `amount` (in previous title) could not be accessed from inside that outer function, only from inside that function.

Each function has its own lexical environment and we have a global environment as well.

When a function is created (i.e. `function func(param){ .. }`), then this function creates a new lexical environment, and registers any kind of variable it has access to inside of this environment. Consider previous function:

```js
function createTaxCalculator(tax) {
  function calculateTax(amount) {
    return amount * tax;
  }
  return calculateTax;
}

const vatAmount = createTaxCalculator(0.19);
const incomeTax = createTaxCalculator(0.25);

console.log(vatAmount(100)); // 19
console.log(incomeTax(200)); // 50
```

When this function is created, something interesting happens. It's in this case (`return amount * tax`), locks in the value for `tax` when this outer function runs. So if we then call that outer function again with a different value, since we execute a brand new function (since we have a totally different function execution), the inner function receives this brand new `tax` value; and it is totally detached from that outer (other) function execution.

What is **closure** here? Every function closes over the surrounding environment, which means it registers the surrounding environment and the variables registered there and it memorizes the the values of these variables. For example:

```js
let multiplier = 1.1;
function createTaxCalculator(tax) {
  function calculateTax(amount) {
    console.log(multiplier);
    return amount * tax * multiplier;
  }
  return calculateTax;
}

const vatAmount = createTaxCalculator(0.19);
const incomeTax = createTaxCalculator(0.25);

multiplier = 1.2;

console.log(vatAmount(100)); // 1.2 - 22.8
console.log(incomeTax(200)); // 1.2 - 60
```

As you can see, the `multiplier` variable is `1.2` in both `vatAmount` and `incomeTax` functions. We changed the `multiplier` value after calling outer function, but before calling the inner function to `1.2`.

It tells us that we do log in `tax` here, because that's part of this specific environment of the outer function when it runs. But we don't log in the concrete value of multiplier. Because that's part of the global environment.

In the end, each function registers its surrounding environments and the variables that are defined in there; and if these variables change and this function uses such a variable. Then it takes the latest value.

