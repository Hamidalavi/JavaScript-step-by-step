# More about Functions

Some notes before starting the **function**:

- Functions are **Code on Demand**.
- Variables and constants created in functions **belong** to that function.
- Functions **can** take parameters (arguments) and **can** return a value.
- Functions can be called multiple times (with different arguments).
- Functions can be called **directly** (IIFE) and **indirectly**.

Throughout this course, you'll hear us use the words **parameters** and **arguments** interchangeably. Technically, there is a difference though:

Parameters are these variables which you specify between parentheses when defining a function.

```js
function hello(name) { .. }
```

In this example, `name` is a **parameter**.

**Arguments** then are the concrete values you pass to a function when calling that function:

```js
hello('Hamid');
```

`'Hamid'` is an **argument** of the function therefore - for the name parameter to be precise.

Since both concepts obviously are extremely close connected, We will often say **let's define which arguments a function receives** or something comparable, since defining the arguments of a function in the end means that you set up its parameters (and vice-versa).

## Method

Objects are usually created to represent entities of the real world, like users, orders and so on:

```js
let user = { name: "Hamid", age: 23 };
```

And, in the real world, a `user` can act: select something from the shopping cart, login, logout etc.

Actions are represented in **JavaScript** by functions in properties.

For a start, let’s teach the `user` to say `"Hello"`:

```js
let user = {
  name: "Hamid",
  age: 23,
};

user.sayHi = function () {
  alert("Hello!");
};

user.sayHi(); // "Hello!"
```

Here we’ve just used a **Function Expression** to create the function and assign it to the property `user.sayHi` of the object. Then we can call it. The `user` can now speak!

A function that is the property of an object is called its **method**.

So, here we’ve got a method `sayHi` of the object `user`. Of course, we could use a pre-declared function as a **method**, like this:

```js
let user = {};

// first, declare
function sayHi() {
  alert("Hello!");
}

// then add as a method
user.sayHi = sayHi;

user.sayHi(); // "Hello!"
```

There exists a shorter syntax for methods in an object literal:

```js
// these objects do the same
user = {
  sayHi: function () {
    alert("Hello");
  },
};

// method shorthand looks better
user = {
  sayHi() {
    // same as "sayHi: function()"
    alert("Hello");
  },
};
```

As demonstrated, we can omit `"function"` and just write `sayHi()`.

**Note**: Functions are object. But why? See the next section.

## Function Expressions

Consider:

```js
function sayHi() {
  console.log("Hi");
}
```

We can store functions in variables or constants. Here, we're using this function as an expression instead of as a declaration (since it's on the right side of equal sign):

```js
const human = function sayHi() {
  console.log("Hi");
};

human(); // "Hi"
```

Therefore it generates a function object. Let's answer the previous question, why `function` is object?

We can use fuctions as **object**, for example:

```js
const human = function sayHi() {
  console.log("Hi");
};

console.log(human.name); // `human` is object and `sayHi` is its property -- "sayHi"
```

We also can use anonymous function in fuction expression. For example:

```js
const start = function () {
  console.log("Start game!");
};

start(); // "Start game!"
```

Function declaration and function expression are havong a small diferrences:

- Function declaration/statement: Hoisted to top, can be declared anywhere in the file (i.e. also after it’s used).
- Function expression: Hoisted to top but not initialized/ defined, can’t be declared anywhere in the file (i.e. not after it’s used).

For example:

```js
func1(); // "Hello!"
function func1() {
  console.log("Hello!");
}

func2(); // ReferenceError: Cannot access 'func2' before initialization
const func2 = function func2() {
  console.log("Hello!");
};
```

Let's repeat **anonymous function** in fuction expression:

```js
const start = function () {
  console.log("Start game!");
};

start(); // "Start game!"
```

We can also use anonymous functions in **addEventListener**, for example:

```js
// named function
function startGame() {
  console.log("Game is starting...");
}

startGameBtn.addEventListener("click", startGame);
```

```js
// anonymous function
startGameBtn.addEventListener("click", function () {
  console.log("Game is starting...");
});
```

## Arrow Function

We can use anonymous functions as **arrow function**. What is that? Consider:

```js
const person = function () {
  console.log("Hello!");
};
```

Arrow function style is:

```js
const person = () => {
  console.log("Hello!");
};
```

This style is special, because we can omit some syntaxes at **arrow** functions. Let's try normal expression function:

```js
const person = function (a) {
  return a;
};
```

Now see how **arrow function** works:

```js
const person = (a) => {
  return a;
};
```

Then, we want omit some syntaxes in **arrow function**:

```js
const person = a =>  a;
```

As you can see, we omitting the `()` parentheses and `return` keyword and `{}` curly braces. Really easy to reading this code.
