# More about Functions

In this course, you learn about:

- Pure Functions & Side Effects
- Factory Functions
- Closures & Scope Revisited
- Recursion

## Pure and Impure Functions

A pure function is a function which for some given input. For some given arguments, always produces the same output (if we reload the page) and it also does not trigger any side effects; which means it does not change anything outside of the function. For example:

```js
function add(num1, num2) {
  return num1 + num2;
}

console.log(add(15, 8)); // 23
```

This is a perfect example for a pure function. It does not change anything outside of function and it always produces the same result for the same outputs.

We also have a impure function that if we call this function, we get the different results there every time we reload the page. For example:

```js
function add(num) {
  return num + Math.random();
}

console.log(add(23)); // 23.????????
```

## Side Effeccts

Let's declare a variable and create a function:

```js
let previousResult = 0

function add(num1, num2) {
  const sum = num1 + num2;
  previousResult = sum;
  return sum;
}
```

This function here would not be pure, because the side effect is `previousResult = sum`. We change a variable that is defined outside of the function (i.e. this function changes something).

Another example for a function with a side effect would be a function that changes an object or an array (change the address) that we pass into it. For example:

```js
const hobbies = ["programming", "gaming"];

function printHobbies(hob) {
  hob.push("Reading");

  console.log(hob);
}

printHobbies(hobbies); // [ 'programming', 'gaming', 'Reading' ]
```

**Note**: You should aim for more pure functions and less impure functions that might introduce side effects.

## Factory Functions

Factory function is a function that produces another function. Consider:

```js
function createTaxCalculator(amount, tax) {
  return amount * tax;
}

console.log(createTaxCalculator(100, 0.19)); // 19
```

We can have functions in a function, fo example:

```js
function createTaxCalculator(tax) {
  function calculateTax(amount) {
    return amount * tax;
  }
  return calculateTax;
}

const vatAmount = createTaxCalculator(0.19);
const incomeTax = createTaxCalculator(0.25);

console.log(vatAmount(100)); // 19
console.log(incomeTax(200)); // 50
```

## Closures - Lexical Scope

Every function in **JavaScript** is a closure. If we create a variable in function (or get a parameter), it's only usable inside of that function, but not outside of it. On the other hand, global variables or constants which are created outside of functions can be used inside of the function. That's something you already knew.

If we have a function in a function, that inner function can use all the variables or parameters of the outer function and all variables and constants that are defined globally.

The outer function cannot access the inner functions, specific constants and variables. For example, `amount` (in previous title) could not be accessed from inside that outer function, only from inside that function.

Each function has its own lexical environment and we have a global environment as well.

When a function is created (i.e. `function func(param){ .. }`), then this function creates a new lexical environment, and registers any kind of variable it has access to inside of this environment. Consider previous function:

```js
function createTaxCalculator(tax) {
  function calculateTax(amount) {
    return amount * tax;
  }
  return calculateTax;
}

const vatAmount = createTaxCalculator(0.19);
const incomeTax = createTaxCalculator(0.25);

console.log(vatAmount(100)); // 19
console.log(incomeTax(200)); // 50
```

When this function is created, something interesting happens. It's in this case (`return amount * tax`), locks in the value for `tax` when this outer function runs. So if we then call that outer function again with a different value, since we execute a brand new function (since we have a totally different function execution), the inner function receives this brand new `tax` value; and it is totally detached from that outer function execution.

What is **closure** here? Every function closes over the surrounding environment, which means it registers the surrounding environment and the variables registered there and it memorizes the the values of these variables. For example:

```js
let multiplier = 1.1;
function createTaxCalculator(tax) {
  function calculateTax(amount) {
    console.log(multiplier);
    return amount * tax * multiplier;
  }
  return calculateTax;
}

const vatAmount = createTaxCalculator(0.19);
const incomeTax = createTaxCalculator(0.25);

multiplier = 1.2;

console.log(vatAmount(100)); // 1.2 - 22.8
console.log(incomeTax(200)); // 1.2 - 60
```

As you can see, the `multiplier` variable is `1.2` in both `vatAmount` and `incomeTax` functions. We changed the `multiplier` value after calling outer function, but before calling the inner function to `1.2`.

It tells us that we do lock in `tax` here, because that's part of this specific environment of the outer function when it runs. But we don't lock in the concrete value of multiplier. Because that's part of the global environment.

In the end, each function registers its surrounding environments and the variables that are defined in there; and if these variables change and this function uses such a variable. Then it takes the latest value.

## Closures in Practice

When a function is created, it's locks in the value (some variable) for `value` when this function runs. Consider:

```js
let userName = "Hamid";

function greetUser() {
  console.log("Hi", userName);
}

greetUser(); // "Hi Hamid"
```

If we change the value of `userName`, it gets the newer one, for example:

```js
let userName = "Hamid";

function greetUser() {
  console.log("Hi", userName);
}

userName = "Hamed";

greetUser(); // "Hi Hamed"
```

We got our `userName` here and it is in the environment outside of the function. It's not part of the function own environment; and therefore the function does close over `let userName = "Hamid";` and would store `userName`. But if that variable then changes, the function reflects that changes.

It doesn't copy the value when it is created and lock that in, it just locks in the variable itself (access the variable), not the value of the variable. When we call the function, indeed then it gets the latest value it can find for that variable. For example:

```js
let userName = "Hamid";

function greetUser() {
  let name = userName;
  console.log("Hi", name);
}

userName = "Hamed";

greetUser(); // "Hi Hamed"
```

The reason for it is the same as before, we do refer to that `userName` variable inside of our function. But when the function executes, it reaches out to that surrounding lexical environment to which it holds a pointer (which the functional the pointer) and gets the latest value from there (i.e. let name = `userName`). Let's consider another example:

```js
let userName = "Hamid";

function greetUser() {
  let name = "Ali";
  console.log("Hi", name);
}

let name = "Reza";

userName = "Hamed";

greetUser(); // "Hi Ali"
```

This is a concept called **shadowing**. The inner function (i.e. the inner environment) wins over the outer environment. This function has it's own lexical environment and there (i.e. `let name = "Ali";`) it adds a `name` variable. It also adds a pointer at the outer lexical environment and there (i.e. `let name = "Reza";`) it also at the time it runs, will have a `name` variable`.

**Important**: When the function executes, it first checks its inner environment (e.g. `let name = "Ali";`) and only if it doesn't find a variable there, then it goes to the next level; **to the outer environment**. So the environment of a surrounding function or the global environment, and then it checks that outer environment for that variable of that `name`. **Functions remember the surrounding variables**. For example:

```js
let userName = "Hamid";

function greetUser() {
//   let name = "Ali";
  console.log("Hi", name);
}

let name = "Reza";

userName = "Hamed";

greetUser(); // "Hi Reza"
```
