# More About DOM & Browser APIs

In this course, you learn about:

- Attaching Data to Elements
- Working with Element Coordinates & Sizes
- Working with Templates & Dynamic Scripts
- `navigator`, `location` & `window.history`

## `data-` Special Attribute and `dataset`

What is `data-`? How can we use them? We know that you hear it for the first time. Consider:

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>dataset</title>
  <script src="assets/scripts/app.js" defer></script>
</head>

<body>

  <ul>
    <li id="prj1" data-extra-info="Got lifetime access!" class="none">
      <button class="alt">More Info</button>
    </li>
  </ul>

</body>

</html>
```

As you can see, we bring you a simple html content. In this content, you see `data-extra-info` attribute in `li` tag. We can access it from **JavaScript** with `element.dataset` property. We can set any kind of data to it, for example:

```js
const btn = document.querySelector("button");
const li = document.getElementById("prj1");
dataset = () => {
  console.log(li.dataset);
};

btn.addEventListener("click", dataset);
/*
DOMStringMap {extraInfo: "Got lifetime access!"}
extraInfo: "Got lifetime access!"
__proto__: DOMStringMap
*/
```

We see the data that named `extraInfo`. **JavaScript** automatically convert `-` dash to camel-Case word.

**Note**: We can use whatever name we want for `data-` attributes, for example `data-whatever` or `data-hamid-alavi` and so on.

These `data-` attributes are (in HTML) all merged together in a `dataset` property.

We can also add this attribute in **JavaScript**, for example:

```js
const li = document.getElementById("prj1");

li.dataset.hamidAlavi = "My name";
/*
// HTML content
<li id="prj1" data-extra-info="Got lifetime access!" class="none" data-hamid-alavi="My name">
     <button class="alt">More Info</button>
</li>
*/
```

We added data with `element.dataset.dataName = "value"` (for example `li.dataset.hamidHamid = "My name";`).

We see the data that named `hamid-alavi`. **JavaScript** automatically add `-` add before UPPERCASE character and converts all words to lowercase.

## Getting Element Box Dimensions

We can get the element box dimensions by `$0.getBoundingClientRect()` method. As you learned before, `$0` is the last element which we selected in **Elements** tab in browser developer tools. Consider, we are selecting the button on any site:

1. First of all, we are going to browser developer tools.
2. Then we select an element (in **Elements** tab).
3. Finally we use this method.

```js
$0.getBoundingClientRect();
/*
DOMRect {x: 787.546875, y: 322.8125, width: 92.6875, height: 36, top: 322.8125, â€¦}
bottom: 358.8125
height: 36
left: 787.546875
right: 880.234375
top: 322.8125
width: 92.6875
x: 787.546875
y: 322.8125
__proto__: DOMRect
*/
```

You need to understand that the browser basically renders the page in a two-dimensional coordinate system with an x-axis from left to right and a y-axis from top to buttom.

**Important**: It's not like a traditional coordinate system where the y-axis would go from buttom to top and x from left to right at the buttom, but instead, it's all starting in the **top left corner**; and that make sense if you consider how a web page is rendered. It's rendered from **top to buttom**, not built up from buttom to top.

In top-left corner, we have `0, 0`x and y axis. Let's talk about `DOMRect` properties:

- **x y**: This basically means that this box (button) which we selected has its top left corner at a position of `322.8125` pixels down and `787.546875` pixels from the left.

- **left right top buttom**: They are exactly the same as x and y, but if we change the margin of that box in the CSS file (or set a negative value), it would be different value from these four directions.

- **width and height**: `width` gives us the total width of the box. `height` gives us the height of the box.

## Working with Element Sizes & Positions

> offset

We can get more specialized data by diving into our DOM element with special properties. For example there is `$0.offsetTop`, `offsetTop` gives us the distance of the topmost point. `offsetTop` always is **relative to our document start, not the viewport** (i.e. it does not change upon scrolling). In last button (box) which we selected, this `offsetTop` value is `323`. We have also `$0.offsetLeft`.

> client

We also however have `$0.clientTop` and `$0.clientLeft`. Now that's a different thing as we can tell, where **offset** property gives us the outer positioning (the position of the box in the coordiante system), the **client** properties give us the inner positioning (without any border and potential scroll bars that might be rendered).

> offsetWidth and offsetHeight

We can get some of the sizes for that box (button), we can get the `$0.offsetWidth` and we can get the `$0.offsetHeight`, and that's the entire width and height of this (that) box (including all border and scroll bars).

> clientWidth and clientHeight

We also have `$0.clientWidth` and `$0.clientHeight` and that's again the inner width and height without borders and scroll bars.

> scroll

We have `$0.scrollHeight`, so this property is the entire height including the non-visible parts (because they're may scrolled out of view).

We also have another interesting value, `$0.scrollTop`. This property gives us information by how much we scroll that content in the box (if you scroll down the page or content, this value will be higher).

> window

One note about the entire document width, if we want to get that, we got two options; we can use `window.innerWidth` and `window.innerHeight` and that should give us the width and height inside of our window (without the developer tools, without the URL bar at the top and so on).

We also have two another properties, `document.documentElement.clientWidth` and `document.documentElement.clientHeight`. These values are more reliable, because they will deduct any visible scroll bars and give us the real width and height that is available.

> scrollTo()

`$0.scrollTo()` method takes two coordinates (x and y), where we can define how much we want to scroll to the left or right and how much we want to scroll to the top or buttom (if you set it to `scrollTo(0, 0)`, this will not be scrollable). We can also pass css (like `top`) property into it. For example, `element.scrollTo({top: 50, behavior: "smooth})`.

> scrollBy()

With `$0.scrollBy()` method, we tell **JavaScript** by how many pixels we want to scroll down. We can also pass css (like `top`) property into it. For example, `element.scrollBy({top: 50, behavior: "smooth})`.

> scrollIntoView({})

With `$0.scrollIntoView({})` method, we can pass css (like `bahavior`) property into it. For example,`element.scrollIntoView({behavior: "smooth"})`.

## Working with template Tags

If we want to add more HTML content by `element.innerHTML`, it would be cumbersome and make us confuse. Thankfully the web has a solution for this. We can use a special HTML tag in our HTML code to kind of setup such to be used HTML code which we don't want to render right from the start, but which we want to eventually use from inside of **JavaScript** code. For this, we can use a special tag, the `template` tag. (`<template></template>`). For eample:

```js
const tooltipTemplate = document.getElementById("tooltip");
const tooltipBody = document.importNode(tooltipTemplate.content, true);
tooltipBody.lastElementChild.textContent = this.text;
// tooltipBody.querySelector("p").textContent = this.text;
tooltipElement.append(tooltipBody);
```

## Loading Scripts Dynamically

There is another cool thing we can with **JavaScript** which many people wouldn't expect or which might be strange when you hear it the first time. We can also create and run a script with **JavaScript**. For example:

```js
const script = document.createElement("script");
script.textContent = "alert('Hello there')";
document.head.append(script);
```

This code is exactly like:

```html
<script>alert('Hello there')</script>
```

Instead of that, we can load scripts with special features, for example accessing the `src` or `defer` property. For example:

```js
const script = document.createElement("script");
script.src = "assets/scripts/test.js";
script.defer = true;
document.head.append(script);
```

For example, if you pass this constant to `addEventListener` (click event), this script file will be executes when button is pressed (you can see this levels (add script file) in developer tools at **Network** tab).

**Warning**: It's a powerful feature, but of course you want to do it with care, you should especially be careful when it comes to dynamically rendering user created scripts, because that opens you up to some attacks here and it is something we'll have a closer look at in the security. In the end, try to inject malicious code into your code. We'll cover it (security) in another courses.
