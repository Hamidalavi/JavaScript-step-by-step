# Meta-programming

In this course, you will learn about:

- Symbols
- Iterators & Generators
- Reflect API
- Proxy API

## Symbol

Symbols like boolean, string, number and so on, are **primitive** value. For example:

```js
const uid = Symbol();
console.log(uid, typeof uid); // Symbol() "symbol"
```

Let's see the example:

```js
const uid = Symbol("uid");

const user = {
  [uid]: "p1",
  name: "Hamid",
  age: 23
};

console.log(user); // { name: 'Hamid', age: 23, [Symbol(uid)]: 'p1' }
```

Or

```js
const uid = Symbol();

const user = {
  [uid]: "p1",
  name: "Hamid",
  age: 23
};

console.log(user); // { name: 'Hamid', age: 23, [Symbol()]: 'p1' }
```

**Important**: Symbols are not equal with together, for example:

```js
console.log(Symbol("uid") === Symbol("uid")); // false
```

It's like the `NaN` value.

Let's look at this example:

```js
const uid = Symbol("uid");

const user = {
  [uid]: "p1",
  name: "Hamid",
  age: 23
};

user[uid] = "p2";
console.log(user); // { name: 'Hamid', age: 23, [Symbol(uid)]: 'p2' }
```

As you can see, we can change the Symbol's value.

If we convert the `user` object to `string`, we will get:

```js
const uid = Symbol("uid");

const user = {
  [uid]: "p1",
  name: "Hamid",
  age: 23
};

user[uid] = "p2";
console.log(user.toString()); // [object Object]
```

Because the `toString()` method called on any object just print `[object Object]` (objects have these prototype and built-in method). We can add a special `Symbol` to the `user` object with a dynamic property assignment (i.e. `[]`) syntax. We can also change the output with the built-in `Symbol.toStringTag`, for example:

```js
// without `toStringTag`
const uid = Symbol("uid");

const user = {
  [uid]: "p1",
  name: "Hamid",
  age: 23,
};

user[uid] = "p2";
console.log(user.toString()); // "[object Object]"


// with `toStringTag`
const uid = Symbol("uid");

const user = {
  [uid]: "p1",
  name: "Hamid",
  age: 23,
  [Symbol.toStringTag]: "User"
};

user[uid] = "p2";
console.log(user.toString()); // "[object User]"
```

## Iterator

An iterator is an object in the end which has a next method. Consider:

```js
const company = {
  employees: ["Hamid", "Hamed", "Ali", "Reza", "Majid", "Mehrdad", "Morteza"]
};
```

We make it iterable or we turn it into an iterator by adding a `next()` method. Consider:

```js
const company = { // step 1
  currentEmployee: 0,
  employees: ["Hamid", "Hamed", "Ali", "Reza", "Majid", "Mehrdad", "Morteza"],
  next() { // step 2
    if (this.currentEmployee >= this.employees.length) { // step 5
      return { value: this.currentEmployee, done: true };
    }
    const returnedValue = { // step 3 and 4
      value: this.employees[this.currentEmployee],
      done: false
    };
    this.currentEmployee++;
    return returnedValue;
  }
};

console.log(company.next()); // { value: 'Hamid', done: false }
console.log(company.next()); // { value: 'Hamed', done: false }
console.log(company.next()); // { value: 'Ali', done: false }
console.log(company.next()); // { value: 'Reza', done: false }
console.log(company.next()); // { value: 'Majid', done: false }
console.log(company.next()); // { value: 'Mehrdad', done: false }
console.log(company.next()); // { value: 'Morteza', done: false }
console.log(company.next()); // { value: 7, done: true }
```

Do you understand it? Well, it's a new thing for you. Let's describe it:

1. We created a simple object with `currentEmployee` and `employees` properties.

2. We made it iterable by adding a `next()` method.

3. In `next()` method, we have two configuration, **one** is `value` and **two** is `done` property.

4. `value` gets a value (property) from object (i.e. `this.employees[this.currentEmployee]`) and `done` is for the stop or start of the iteration.
   - `true`: stop iterating
   - `false`: start iterating

5. We stopped the iteration with `if` statement (done: `true`).

We can dynamically loop them with `while` loop:

```js
const company = {
  currentEmployee: 0,
  employees: ["Hamid", "Hamed", "Ali", "Reza", "Majid", "Mehrdad", "Morteza"],
  next() {
    if (this.currentEmployee >= this.employees.length) {
      return { value: this.currentEmployee, done: true };
    }
    const returnedValue = {
      value: this.employees[this.currentEmployee],
      done: false
    };
    this.currentEmployee++;
    return returnedValue;
  }
};

let employee = company.next();

while (!employee.done) {
  console.log(employee.value);
  employee = company.next();
}
/*
"Hamid"
"Hamed"
"Ali"
"Reza"
"Majid"
"Mehrdad"
"Morteza"
 */
```

**Note**: This would be one example how you can use your own iterator. `company`, which has this `next()` method which in turn allows you to have your own looping logic for whichever filed or whichever logic related to this `company` object you might have. That means you don't have to loop the entire `company` object.

## Generator

We can't use `for..of` loop in this example, for example:

```js
const company = {
  currentEmployee: 0,
  employees: ["Hamid", "Hamed", "Ali", "Reza", "Majid", "Mehrdad", "Morteza"],
  next() {
    if (this.currentEmployee >= this.employees.length) {
      return { value: this.currentEmployee, done: true };
    }
    const returnedValue = {
      value: this.employees[this.currentEmployee],
      done: false
    };
    this.currentEmployee++;
    return returnedValue;
  }
};

let employee = company.next();

for (employee of company) {
  console.log(employee.value); // TypeError: company is not iterable
}
```

We can make this iterable with **generator**. Consider:

```js
const company = {
  currentEmployee: 0,
  employees: ["Hamid", "Hamed", "Ali", "Reza", "Majid", "Mehrdad", "Morteza"],
  next() {
    if (this.currentEmployee >= this.employees.length) {
      return { value: this.currentEmployee, done: true };
    }
    const returnedValue = {
      value: this.employees[this.currentEmployee],
      done: false
    };
    this.currentEmployee++;
    return returnedValue;
  },

  [Symbol.iterator]: function* employeeGenerator() {
    let employee = company.next();

    for (employee of company) {
      console.log(employee.value);
    }
  }
};
```

Here we used special `Symbol.iterator` for make this object iterable.

We can write our looping logic inside of this generator. We can move our `while` loop logic here from buttom into our `employeeGenerator` generator.

**Note**: Every function that have a `*` symbol, that function is a generator.

So instead of using `console.log(employee.value);`, we must use `yield` keyword (i.e. `yield employee.value`). `yield` in the end, generates a new object; `employeeGenerator` function when it's called generates a new object which has a `next()` method on its own. That means we can remove our custom `next()` method:

```js
const company = {
  currentEmployee: 0,
  employees: ["Hamid", "Hamed", "Ali", "Reza", "Majid", "Mehrdad", "Morteza"],
  next() {
    if (this.currentEmployee >= this.employees.length) {
      return { value: this.currentEmployee, done: true };
    }
    const returnedValue = {
      value: this.employees[this.currentEmployee],
      done: false
    };
    this.currentEmployee++;
    return returnedValue;
  },

  [Symbol.iterator]: function* employeeGenerator() {
    let employee = company.next();

    for (employee of company) {
      yield employee.value;
      console.log(employee.value);
    }
  }
}; // no output (just for showing `yield` keyword)
```

**Note**: `yield` basically is the point where **JavaScript** saves the current state of execution and the next time we call the `next()` method on the created iterator, it will continue from that point.

So we can remove the `next()` method. We can also remove the `[Symbol.iterator]`, because generators are iterable:

```js
const company = {
  employees: ["Hamid", "Hamed", "Ali", "Reza", "Majid", "Mehrdad", "Morteza"],
  getEmployee: function* employeeGenerator() {
    let currentEmployee = 0;
    while (currentEmployee < this.employees.length) {
      yield this.employees[currentEmployee];
    }
  }
};

console.log(company.getEmployee().next()); // { value: 'Hamid', done: false }
console.log(company.getEmployee().next()); // { value: 'Hamid', done: false }
console.log(company.getEmployee().next()); // { value: 'Hamid', done: false }
... // { value: 'Hamid', done: false }
```

As you can see, it's easy to understand and easy to use. But look at the result, all of the are `{ value: 'Hamid', done: false }`. The reason for that is that whenever we call `getEmployee`, we generate a new iterator. So instead what we should do, is we should create a new constant and call `company.getEmployee()` once and then use that same object all the time.

**Note**: Make sure that in your generator logic, you also need increment `currentEmployee` by `1`:

```js
const company = {
  employees: ["Hamid", "Hamed", "Ali", "Reza", "Majid", "Mehrdad", "Morteza"],
  getEmployee: function* employeeGenerator() {
    let currentEmployee = 0;
    while (currentEmployee < this.employees.length) {
      yield this.employees[currentEmployee];
      currentEmployee++;
    }
  }
};

let it = company.getEmployee();

console.log(it.next()); // { value: 'Hamid', done: false }
console.log(it.next()); // { value: 'Hamed', done: false }
console.log(it.next()); // { value: 'Ali', done: false }
console.log(it.next()); // { value: 'Reza', done: false }
console.log(it.next()); // { value: 'Majid', done: false }
console.log(it.next()); // { value: 'Mehrdad', done: false }
console.log(it.next()); // { value: 'Morteza', done: false }
console.log(it.next()); // { value: undefined, done: true }
```

**Q**: Why is that useful?

**Answer**: We don't have to write our own `next()` method as we did before, we just have this short logic here and `yield` is the special thing here together with the `*` (i.e. `function*`). This allows **JavaScript** to build such an iterator behind the scenes; and whenever `yield` is encountered, this basically is the point where **JavaScript** saves the current state of execution and the next time we call the `next()` method on the created iterator, it will continue from that point on, and therefore then give us the next value and the next value and the ... .

In the end, we can use the special `[Symbol.iterator]` instead of `getEmployee` and use `for..of` loop:

```js
const company = {
  employees: ["Hamid", "Hamed", "Ali", "Reza", "Majid", "Mehrdad", "Morteza"],
  [Symbol.iterator]: function* employeeGenerator() {
    let currentEmployee = 0;
    while (currentEmployee < this.employees.length) {
      yield this.employees[currentEmployee];
      currentEmployee++;
    }
  }
};

for (const employee of company) {
  console.log(employee);
}
/*
"Hamid"
"Hamed"
"Ali"
"Reza"
"Majid"
"Mehrdad"
"Morteza"
 */
```

Because what a `for..of` loop does, is it goes to `company` object we're looping through and it searches for this `[Symbol.iterator]` thing there. Then it executes the function which it finds there, which should be a generator. So that in the end, this returns an iterator.

**Note**: If you execute that generator function, you get an iterator as you learned before; and then **JavaScript** executes the `next()` method on this iterator it got, for you as long as `done` is `false` (not `true`) and extracts the thing in the `value` property into this `const` (i.e. `const employee of company`) which you can then use and consume inside of your `for..of` loop body (i.e. `console.log(employee);`).

We can also use spread operator, because the `...` spread operator also behind the scenes looks for `[Symbol.iterator]`:

```js
const company = {
  employees: ["Hamid", "Hamed", "Ali", "Reza", "Majid", "Mehrdad", "Morteza"],
  [Symbol.iterator]: function* employeeGenerator() {
    let currentEmployee = 0;
    while (currentEmployee < this.employees.length) {
      yield this.employees[currentEmployee];
      currentEmployee++;
    }
  }
};

for (const employee of company) {
  console.log(employee);
}
/*
"Hamid"
"Hamed"
"Ali"
"Reza"
"Majid"
"Mehrdad"
"Morteza"
 */

console.log([...company]);
/*
(7) ["Hamid", "Hamed", "Ali", "Reza", "Majid", "Mehrdad", "Morteza"]
  0: "Hamid"
  1: "Hamed"
  2: "Ali"
  3: "Reza"
  4: "Majid"
  5: "Mehrdad"
  6: "Morteza"
  length: 7
  __proto__: Array(0)
 */
```

It goes through all the values and adds them as elements here in this new array (i.e. `[...company]`).

**Summary**: We can write our own `for..of` loopable objects with the help of this special well-known `[Symbol.iterator]` and generator function.

## `Reflect` API

`Reflect` is related to the objects (not Symbols, not Iterators and not Generator). The `Reflect` API gives us a bunch of static methods that help us change objects (work with objects on a meta level).

`Reflect` API is like that `Object` global object. But there are four different reasons that you should use this API:

- `Reflect` API is new added in **JavaScript** (beyond **ES6**).
- It gives us a better and understandable error.
- It gives us a bunch of static methods that help us change objects (usable methods).
- A better way for deleting and adding a property, change the object prototype(s) and so on.

Consider:

```js
const person = {
  name: "Hamid"
};

Object.deleteProperty(person, "name"); // TypeError: Object.deleteProperty is not a function
```

We can't use this method for deleting properties. Instead we can use `delete` keyword:

```js
const person = {
  name: "Hamid"
};

delete person.name;

console.log(person); // {}
```

We can `deleteProperty` in `Reflect` API, for example:

```js
const person = {
  name: "Hamid"
};

Reflect.deleteProperty(person, "name");

console.log(person); // {}
```

## Comparing `Reflect` and `Object` Methods

The `Reflect` object, introduced in **ES6**, is a built-in object that provides methods to interface with **JavaScript** objects. Some of the static functions that exist on `Reflect` also correspond to methods available on `Object`, which predates **ES6**. Although some of the methods appear to be similar in their behavior, there are often subtle differences between them.

The table below details the differences between the methods available on the `Object` and `Reflect` APIs. Please note that if a method does not exist in an API, it is marked as **N/A**.

|Method Name|`Object`|`Reflect`|
|:-:|:-:|:-:|
|`defineProperty()`|`Object.defineProperty()` returns the object that was passed to the function. Returns a `TypeError` if the property was not successfully defined on the object.|`Reflect.defineProperty()` returns `true` if the property was defined on the object and `false` if it was not.|
|`defineProperties()`|`Object.defineProperties()` returns the objects that were passed to the function. Returns a `TypeError` if any properties were not successfully defined on the object.|N/A|
|`set()`|N/A|`Reflect.set()` returns `true` if the property was set successfully on the object and `false` if it was not. Throws a `TypeError` if the target was not an `Object`.|
|`get()`|N/A|`Reflect.get()` returns the value of the property. Throws a `TypeError` if the target was not an `Object`.|
|`deleteProperty()`|N/A|`Reflect.deleteProperty()` returns `true` if the property was deleted from the object and `false` if it was not.|
|`getOwnPropertyDescriptor()`|`Object.getOwnPropertyDescriptor()` returns a property descriptor of the given property if it exists on the object argument passed in, and returns `undefined` if it does not exist. However, if an object is not passed in as the first argument, it will be coerced into an object.|`Reflect.getOwnPropertyDescriptor()` returns a property descriptor of the given property if it exists on the object. Returns `undefined` if it does not exist, and a `TypeError` if anything other than an object (a primitive) is passed in as the first argument.|
|`getOwnPropertyDescriptors()`|`Object.getOwnPropertyDescriptors()` returns an object containing a property descriptor of each passed-in object. Returns an empty object if the passed-in object has no owned property descriptors.|N/A|
|`getPrototypeOf()`|`Object.getPrototypeOf()` returns the prototype of the given object. Returns `null` if there are no inherited properties. Throws a `TypeError` for non-objects in **ES5**, but coerces non-objects in **ES6**.|`Reflect.getPrototypeOf()` returns the prototype of the given object. Returns `null` if there are no inherited properties, and throws a `TypeError` for non-objects.|
|`setPrototypeOf()`|`Object.setPrototypeOf()` returns the object itself if its prototype was set successfully. Throws a `TypeError` if the prototype being set was anything other than an `Object` or `null`, or if the prototype for the object being modified is non-extensible.|`Reflect.setPrototypeOf()` returns `true` if the prototype was successfully set on the object and `false` if it wasn't (including if the prototype is non-extensible). Throws a `TypeError` if the target passed in was not an `Object`, or if the prototype being set was anything other than an `Object` or `null`.|
|`isExtensible()`|`Object.isExtensible()` returns `true` if the object is extensible, and `false` if it is not. Throws a `TypeError` in **ES5** if the first argument is not an object (a primitive). In **ES6**, it will be coerced into a non-extensible, ordinary object and will return `false`.|`Reflect.isExtensible()` returns `true` if the object is extensible, and `false` if it is not. Throws a `TypeError` if the first argument is not an object (a primitive).|
|`preventExtensions()`|`Object.preventExtensions()` returns the object that is being made non-extensible. Throws a `TypeError` in **ES5** if the argument is not an object (a primitive). In **ES6**, treats the argument as a non-extensible, ordinary object and returns the object itself.|`Reflect.preventExtensions()` returns `true` if the object has been made non-extensible, and false if it has not. Throws a `TypeError` if the argument is not an object (a primitive).|
|`keys()`|`Object.keys()` returns an `Array` of strings that map to the target object's own (enumerable) property keys. Throws a `TypeError` in **ES5** if the target is not an object, but coerces non-object targets into objects in **ES6**.|N/A|
|`ownKeys()`|N/A|`Reflect.ownKeys()` returns an `Array` of property names that map to the target object's own property keys. Throws a `TypeError` if the target is not an Object.|

<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#A_complete_traps_list_example>

