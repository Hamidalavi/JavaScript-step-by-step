# Introduction to Testing

In this course, you will learn about:

- Unit Tests
- Integration Tests
- End-to-End (E2E) Tests
- Test Both Synchronous & Asynchronous Code

## What is Testing

**Q**: Why would we want to test?

**Answer**:

1. We want to get an error and see the error if we break our code, we want to see that immediately without us testing everything manually.
2. We'll also save time if we don't have to set everything manulally over and over again.
3. We're also forced to think about possible issues ore bugs when writing our tests.
4. We can also integrate it into our build wokflow, **i.e** we have a workflow that automatically is triggered where this code is then tested in the cloud on some server and if the test succeeds, it's maybe deployed automatically.
5. We can also break up complex dependencies, we have to make sure we write code that can be split up. That is modular, because this will make testing easier and ultimately it will make working with our code easier.
6. It improves our code.

## Different Kinds of Tests

- We have some tests that test a fully isolated piece of code (e.g. testing one function). Let's say a function that takes some input and returns some output. We can test such a function with a test, because it has a clearly defined structure and we can say for input `x` and `y`, we expect to get output `z`; and that would be a so-called **Unit Test**. Because we test a single, isolated unit of our application.

- We also have some tests that test units with some dependencies. So we have no isolated piece of code anymore, but we might have a function that calls another function; and therefore the function we're testing depends on the result of another function and that is called an **Integration Tests**. Because there, we're testing more than just a single unit.

- We also have the full flow which we can test or the user interface; so the full application or a part of the full application; and this is so-called **End-to-End** or also user interface test (e.g. validating the DOM after a click).

## Working with Unit Test

First of all, we need to install `webpack` and `webpack-cli` packages from `npm`. Let's consider these files:

```html
<!-- HTML content -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="styles.css">
    <title>JS Testing</title>
</head>

<body>
    <section class="control-panel">
        <div class="input-container">
            <label for="name">Name</label>
            <input type="text" id="name">
        </div>
        <div class="input-container">
            <label for="age">Age</label>
            <input type="number" id="age">
        </div>
        <button id="btnAddUser" class="button">Add User</button>
    </section>
    <hr>
    <section class="user-output">
        <ul class="user-list"></ul>
    </section>
    <script src="dist/main.js"></script>
</body>

</html>
```

```js
// app.js file
const { generateText, createElement, validateInput } = require("./util");

const initApp = () => {
  const newUserButton = document.getElementById("btnAddUser");
  newUserButton.addEventListener("click", addUser);
};

const addUser = () => {
  const newUserNameInput = document.getElementById("name");
  const newUserAgeInput = document.getElementById("age");

  if (
    !validateInput(newUserNameInput.value, true, false) ||
    !validateInput(newUserAgeInput.value, false, true)
  ) {
    return;
  }

  const userList = document.querySelector(".user-list");
  const outputText = generateText(
    newUserNameInput.value,
    newUserAgeInput.value
  );
  const element = createElement("li", outputText, "user-item");
  userList.append(element);
};

initApp();
```

```js
// util.js file
exports.generateText = (name, age) => {
  return `${name} (${age} years old)`;
};

exports.createElement = (type, text, className) => {
  const newElement = document.createElement(type);
  newElement.classList.add(className);
  newElement.textContent = text;
  return newElement;
};

exports.validateInput = (text, notEmpty, isNumber) => {
  if (!text) {
    return false;
  }
  if (notEmpty && text.trim().length === 0) {
    return false;
  }
  if (isNumber && +text === NaN) {
    return false;
  }
  return true;
};
```

```json
json file
{
  "name": "js-testing-introduction",
  "version": "1.0.0",
  "description": "An introduction to JS testing",
  "main": "app.js",
  "scripts": {
    "start": "webpack app.js --mode development --watch",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "js",
    "javascript",
    "testing",
    "jest",
    "unit",
    "tests",
    "integration",
    "tests",
    "e2e",
    "tests"
  ],
  "author": "Hamid Alavi",
  "license": "ISC",
  "devDependencies": {
    "webpack": "^4.20.2",
    "webpack-cli": "^3.1.2"
  }
}
```

We want to test our application with `jest.js` library, for do that, we need to install it with `npm install --save-dev jest` command. You can install all of them easily with `npm install` command. Then we have:

```json
{
  "name": "js-testing-introduction",
  "version": "1.0.0",
  "description": "An introduction to JS testing",
  "main": "app.js",
  "scripts": {
    "start": "webpack app.js --mode development --watch",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "js",
    "javascript",
    "testing",
    "jest",
    "unit",
    "tests",
    "integration",
    "tests",
    "e2e",
    "tests"
  ],
  "author": "Hamid Alavi",
  "license": "ISC",
  "devDependencies": {
    "jest": "^26.6.3",
    "webpack": "^4.20.2",
    "webpack-cli": "^3.1.2"
  }
}
```

We can write our first test and we'll write our test for functions defined in `util.js`. So the first function (i.e. `generateText`) makes up for a great first **unit test**. It has no other dependencies, because it doesn't call any other functions, it doesn't reach out to the web or anything like that; it simply takes input, two arguments and returns an output.

Now to write a test for this function, we create a separate file into which we'll store our tests. We can create a test files with `.spec.js` or `.test.js` extension. We recommend you to use `.test.js` (i.e. `util.test.js`).

`jest` will automatically detect files with `.test.js` or `.spec.js` in them, it will run them automatically once we run `jest`. Let's import that function into our `util.test.js` script file:

```js
const { generateText } = require("./util");
```

**Note**: `import { generateText } from "./util";` will not work. Not only because we not using **ES6** exports here, that is also a problem; but even if we would use them, this is not a syntax natively supported by `jest`.

For the first start, we write `test()` function. This is a function which is now globally available in `jest`. This function takes two parameters, first one is for the test name or description. The second function argument is then an anonymous function which we pass in, which is the function `jest` will execute to really run our tests.

```js
const { generateText } = require("./util");

test("should output name and age", () => {
  const text = generateText("Hamid", 23);
});
```

We can formulate that function with `expect()` function which is also provided by `jest`. For example the ouput must be `"Hamid Alavi (23)"`, then we need to use `toBe()` function, for example:

```js
const { generateText } = require("./util");

test("should output name and age", () => {
  const text = generateText("Hamid", 23);
  expect(text).toBe("Hamid Alavi (23 years old)");
});
```

For testing our code, we need to change the `"test"` script to `"jest"` in `package.json` file (i.e. `"echo \"Error: no test specified\" && exit 1"` to `"jest"`). This will automatically search for files with `.test.js` or `.spec.s` in the name and execute them. Now we can easily test our script with `npm test` command.

```js
$ npm test

> js-testing-introduction@1.0.0 test C:\Users\ultih\OneDrive\Documents\14. Testing
> jest

 FAIL  ./util.test.js
  × should output name and age (16 ms)

  ● should output name and age

    expect(received).toBe(expected) // Object.is equality

    Expected: "Hamid Alavi (23"
    Received: "Hamid (23 years old)"

      3 | test("should output name and age", () => {
      4 |   const text = generateText("Hamid", 23);
    > 5 |   expect(text).toBe("Hamid Alavi (23");
        |                ^
      6 | });
      7 |

      at Object.<anonymous> (util.test.js:5:16)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        5.106 s
Ran all test suites.
npm ERR! Test failed.  See above for more details.
```

This test failed, because we put `"Hamid"` instead of `"Hamid Alavi"`. If we change it to `"Hamid Alavi"`, then:

```js
$ npm test

> js-testing-introduction@1.0.0 test C:\Users\ultih\OneDrive\Documents\14. Testing
> jest

 PASS  ./util.test.js
  √ should output name and age (5 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        5.116 s
Ran all test suites.
```

We can see the real-time test with `"test": "jest --watchAll"` in `package.json` file.

**Note**: You can check more than one thing in a **Unit Test** (by adding more `test()` and `expect()` functions).
