# Meta-programming

In this course, you will learn about:

- Symbols
- Iterators & Generators
- Reflect API
- Proxy API

## Symbol

Symbols like boolean, string, number and so on, are **primitive** value. For example:

```js
const uid = Symbol();
console.log(uid, typeof uid); // Symbol() "symbol"
```

Let's see the example:

```js
const uid = Symbol("uid");

const user = {
  [uid]: "p1",
  name: "Hamid",
  age: 23
};

console.log(user); // { name: 'Hamid', age: 23, [Symbol(uid)]: 'p1' }
```

Or

```js
const uid = Symbol();

const user = {
  [uid]: "p1",
  name: "Hamid",
  age: 23
};

console.log(user); // { name: 'Hamid', age: 23, [Symbol()]: 'p1' }
```

**Important**: Symbols are not equal with together, for example:

```js
console.log(Symbol("uid") === Symbol("uid")); // false
```

It's like the `NaN` value.

Let's look at this example:

```js
const uid = Symbol("uid");

const user = {
  [uid]: "p1",
  name: "Hamid",
  age: 23
};

user[uid] = "p2";
console.log(user); // { name: 'Hamid', age: 23, [Symbol(uid)]: 'p2' }
```

As you can see, we can change the Symbol's value.

If we convert the `user` object to `string`, we will get:

```js
const uid = Symbol("uid");

const user = {
  [uid]: "p1",
  name: "Hamid",
  age: 23
};

user[uid] = "p2";
console.log(user.toString()); // [object Object]
```

Because the `toString()` method called on any object just print `[object Object]` (objects have these prototype and built-in method). We can add a special `Symbol` to the `user` object with a dynamic property assignment (i.e. `[]`) syntax. We can also change the output with the built-in `Symbol.toStringTag`, for example:

```js
// without `toStringTag`
const uid = Symbol("uid");

const user = {
  [uid]: "p1",
  name: "Hamid",
  age: 23,
};

user[uid] = "p2";
console.log(user.toString()); // "[object Object]"


// with `toStringTag`
const uid = Symbol("uid");

const user = {
  [uid]: "p1",
  name: "Hamid",
  age: 23,
  [Symbol.toStringTag]: "User"
};

user[uid] = "p2";
console.log(user.toString()); // "[object User]"
```
