# Working with the Document Object Model (DOM) in JavaScript

In this course, you learn about:

- HTML and DOM
- Nodes and Elements
- Querying DOM Nodes and Traversing the DOM
- Evaluating and Manipulating DOM Nodes
- Creating and Removing DOM Nodes

## `document` and `window`

You can access your **HTML** skeleton by `ducument`. For example:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DOM Interaction</title>
  <script src="app.js" defer></script>
</head>
<body>


</body>
</html>
```

We can aslo use `console.dir(document)`.  The `console.dir()` displays an interactive list of the properties of the specified **JavaScript** object. In other words, `console.dir()` is the way to see all the properties of a specified **JavaScript** object in console by which the developer can easily get the properties of the object:

```js
console.dir(document);
```

Now we get access to real **JavaScript** object with all the properties that are in there and you see, there are a lot of properties in there.

`document` element here is basically our entire **HTML** content. So, the `body` gives us access to everything that was rendered in that body part, **HTML** holds everything that was rendered to set up for our entire HTML code which was rendered.

We also can type `window` here (console) and we get access to the window object. This is that real topmost object and this gives us access to all the core APIs that the browser wants to expose to us (like `alert()`, `prompt()`, `print()`, `blur()` and so on).

Actually browsers always parse our **JavaScript** code such that `window.` is automatically added in front of some function if that function can't be found anywhere else. So the browser always looks in the `window` object if we're calling or accessing something, which is like `alert()` would work here, so that's really great. For example:

```js
alert("Hey");
// or
window.alert("Hey");
```

![DOM](https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/DOM-model.svg/1200px-DOM-model.svg.png)

## Small theory of `document` and `window`

**document**:

- Root DOM Node
- Provides access to element querying, DOM content etc.

**window**:

- The active Browser Window / Tab
- Acts as global storage for script, also provides access to window- specific properties and methods

## Element and Node

We can use in our HTML documents which are understood by the browser and which will be rendered to the screen. Browser renders all the pixels. For example, the `html` tag is translated to an `HTML` node.

Text node: The whitespaces in HTML file is also is **node**. Most whitespaces is actually not rendered but it is part of the that DOM tree. But of course, also the normal text is part of the DOM as **text node**. Text is indeed stored as objects but as a different kind of object, as a **text nodes** with different properties and different methods. So we have to type of node, 1. text node, 2. element node.

You can see your HTML elements in `developer tools` in browser, in **Elements** tab. You can also press `ctrl+shift+c` to use slecetion mode (or cursor icon in developer tools).

**Note**: `$0` always gives you access to the **last element you selected** in the `Elements` tab.

A Summary of describing `element` and `node`:

|Node|Element|
|:-:|:-:|
|The objects that make up the DOM|Special properties and methods to interact with the elements|
|HTML tags are **element nodes** (or just **elements**)|Available methods and properties depend on the kind of element|
|Text creates **text nodes**|Can be selected in various different ways (via **JavaScript**)|
|Attributes create **attribute nodes**|Can be created and removed via **JavaScript**|

**Note**: Elements are one type of nodes.

More information from Node Type: [Click here](https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType)

## Querying Elements

We have some different ways for querying elements, for example:

- `querySelector()`
- `querySelectorAll()`
- `getElementById()`
- `getElementByClassName()`
- `getElementByTagName()`
- and etc.

DOM nodes are just **JavaScript Object** in the end - i.e. **reference values**.These methods **return the object references (addresses)

> `querySelector()`, `getElementById()`

- Return single elements
- Differents ways of querying elements (by CSS selector, by ID)
- Direct reference to DOM elements is returned

> `querySelectorAll()`, `getElementByTagName()`, ...

- Returns collections of elements (array-like objects): NodeList
- Different ways of querying elements (by CSS selector, by tag name, by CSS class)
- `querySelectorAll()` returns a non-live NodeList, getXByY return live NodeLists

## Selecting Elements in the DOM

As you learned from the **Querying Elements** section, we want make some example:

Querying elements by class and id:

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DOM Interaction</title>
  <script src="app.js" defer></script>
</head>

<body>
  <header>
    <h1 id="main-title">Dive into the DOM!</h1>
  </header>
  <ul>
    <li class="list-item">list1</li>
    <li class="list-item">list2</li>
    <li class="list-item">list3</li>
  </ul>
  <script>
    document.getElementById(`main-title`); // gets this `h1` element
    document.getElementByClassName(`main-title`); // gets these `li` elements
  </script>
</body>

</html>
```

If you want find (select) the first matching items (elements) in class (and etc.), you use to use `querySelector()` for return to first matching item:

```js
document.querySelector('.list-item');
// <li class="list-item">list1</li>
```

If you have all matching items you use `document.querySelectorAll()` and then enter your CSS selector in there:

```js
document,querySelectorAll('.list-item');
// NodeList(3) [li.list-item, li.list-item, li.list-item]
// 0: li.list-item
// 1: li.list-item
// 2: li.list-item
// length: 3
// __proto__: NodeList
```

You can use different ways for `querySelector()`, for example:

```js
// selects first element match
document.querySelectorAll('ul li:first-of-type');
// <li class="list-item">list1</li>

// selects last element match
document.querySelectorAll('ul li:last-of-type');
// <li class="list-item">list3</li>
```

You can also store them into variable:

```js
const ul = document.querySelector('ul');
<li class="list-item">list1</li>
// <li class="list-item">list1</li>
```

## Summary of DOM

Here's a summary of the various methods you got to reach out to DOM elements (you can only query for element nodes).

Besides the below query methods, you also got these special properties on the `document` object to select parts of the document:

- `document.body` => Selects the `<body>` element node.
- `document.head` => Selects the `<head>` element node.
- `document.documentElement` => Selects the `<html>` element node.

> Query Methods

- `document.querySelector(<CSS selector>)`

  Takes any CSS selector (e.g. `'#some-id'`, `'.some-class'` or `'div p some-class'`) and returns the first (!) matching element in the DOM. Returns `null` if no matching element could be found.

  More information about `document.querySelector()`: <https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector>

- `document.getElementById(<ID>)`

  Takes an ID (**without `#`**, just the id name) and returns the element that has this `id`. Since the same ID shouldn't occur more than once on your page, it'll always return exactly that one element. Returns `null` if no element with the specified ID could be found.

  More information about `document.getElementById(<ID>)`: <https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById>

- `document.querySelectorAll(<CSS selector>)`

  Takes any CSS selector (e.g. `'#some-id'`, `'.some-class'` or `'div p.some-class'`) and returns all matching elements in the DOM as a static (non-live) NodeList. Returns and empty NodeList if no matching element could be found.

  More information about `document.querySelectorAll(<CSS selector>)`: <https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll>

- `document.getElementsByClassName(<CSS CLASS>)`

  Takes a CSS class (**without `.`**, just the class name, e.g. `'some-class'`) and returns a live HTMLCollection of matched elements in your DOM. Returns an empty HTMLCollection if not matching elements were found.

  More information about `document.getElementsByClassName(<CSS CLASS>)`: <https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName>

- `document.getElementsByTagName(<HTML TAG>)`

  Takes an HTML tag (e.g. `'p'`) and returns a live HTMLCollection of matched elements in your DOM. Returns an empty HTMLCollection if not matching elements were found.

  More information about `document.getElementsByTagName(<HTML TAG>)`: <https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName>

There also is the `getElementsByName()` method which really isn't used commonly (<https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByName>).

## Evaluating and Manipulating DOM Nodes (Elements)

Consider:

```html
<h1 id="main-title">Dive into the DOM!</h1>
```

We can access all properties and attributes in HTML `tag`. For example:

```js
const h1 = document.querySelector('h1');
h1.textContent; // "Dive into the DOM!"
h1.textContent = "Some new text!"; // "Some new text!"

h1.className; // ""
h1.className = "title"; // <h1 id="main-title" class="title">Dive into the DOM!</h1>

h1.id; // "main-title"
h1.id = "new-title"; // <h1 id="new-title" class="title">Dive into the DOM!</h1>
```

We also can access the CSS properties by `style`:

```js
const h1 = document.querySelector('h1');
h1.style.color; // ""
h1.style.color = "white"; // color: white;

h1.style.backgroundColor; // ""
h1.style.backgroundColor = "red"; // background-color: red;
```

We would recommend that you absolutely use `console.dir(h1)` (or other elements), because whilst there are many things which you won't fully understand yet. There are many things which you will understand.

**Note**: Whatever you change here (in browser console), in **JavaScript**, will be lost whenever you reload the page, because what you do in **JavaScript** is only stored in memory. If you reload the page, you load these original files again and your **JavaScript** changes are lost. Because whenever you reload the page, this essentially resets your **JavaScript** application, it clears the existing application from the memory in the end and starts a brand new application. So your **JavaScript** file is parsed again and any changes you made are not kept around.

## Attributes vs Properties

When the browser loads the page, it **reads** (another word: **parses**) the HTML and generates DOM objects from it. For element nodes, most standard HTML attributes automatically become properties of DOM objects.

For instance, if the tag is `<body id="page">`, then the DOM object has `body.id="page"`.

But the attribute-property mapping is **not one-to-one**! In this chapter weâ€™ll pay attention to separate these two notions, to see how to work with them, when they are the same, and when they are different.

- Attributes: Is whatâ€™s written in HTML
- Properties: Is whatâ€™s in DOM objects

Methods to work with **attributes** are:

- `element.hasAttribute(name)`: To check for existence.
- `element.getAttribute(name)`: To get the value.
- `element.setAttribute(name, value)`: To set the value.
- `element.removeAttribute(name)`: To remove the attribute.
- `element.attributes` is a collection of all attributes.

We have a lot of attributes. You can take a look in [this](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes) site.

> Summary:

Often (but not always!), **attributes** are mapped to **properties** and **live synchronization** is set up. Consider:

```html
<input id="input-1" class="input-default" value="Enter text...">
```

`id="input-1"`, `class="input-default"` and `value="Enter text..."` are attribute placed in HTML code, on element tags.

These are properties:

```js
const input; // read below
```

- 1:1 mapping (+ live-sync) => `input.id`
- Different names (but live-sync) => `input.className`
- 1:1 mapping (1-way live-sync) => `input.value`

Properties automatically added on created DOM objects.

Let's do a mini project:

```html
<!-- HTML content -->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DOM Interaction</title>
  <script src="app.js" defer></script>
</head>

<body>
  <button id="start-btn">Click me!</button>
  <header>
    <h1 id="main-title">Dive into the DOM!</h1>
  </header>
  <ul>
    <li class="list-item">list1</li>
    <li class="list-item">list2</li>
    <li class="list-item">list3</li>
  </ul>
</body>

</html>
```

```js
// JavaScript code
const startBtn = document.getElementById("start-btn");
const h1 = document.getElementById(`main-title`);
const allLis = document.getElementsByTagName("li");
const lastLi = document.querySelector(`.list-item:last-of-type`);

const start = () => {
  for (const li of allLis) {
    console.log(li);
  }

  h1.textContent = "We changed you, Sorry!";
  h1.style.color = "white";
  h1.style.backgroundColor = "black";

  lastLi.textContent = lastLi.textContent + " Changed";
};

startBtn.addEventListener("click", start);
```

## Travesring the DOM

A good **JavaScript** developer needs to know how to traverse the DOM â€” itâ€™s the act of selecting an element from another element.

But why do we need to learn to traverse the DOM? Isnâ€™t `document.querySelector()` enough for most of our needs?

**Why we traverse**?

Letâ€™s say you want to go to your neighborâ€™s house. Whatâ€™s the fastest and most efficient way to get there?

- Move from your house to their house (since you already know their address).
- Lookup their address on Google maps, then walk according to the directions Google gives you.

If you move directly from your house to their house, youâ€™re doing the equivalent of **traversing the DOM** - selecting one element from a neighboring element.

If you lookup their address on Google, youâ€™re doing the equivalent of `document.querySelector()` to find elements. Can you guess which method is more efficient?

```js
  <div class="neighborhood">
    <div class="your-house">ðŸ˜Ž</div>
    <div class="neighbor-house">ðŸŽ‰</div>
  </div>
```

You probably know the answer; itâ€™s always easier to move from an element to another. Thatâ€™s why we traverse the DOM. You can traverse in three directions:

- **Upwards**: `element.parentNode`, `element.parentElement` and `element.closest`.

- **Sideways**: `element.nextSibling`, `element.previousSibling`, `element.nextElementSibling`, `element.previousElementSibling` and Combining `parentElement`, `children`, and `index`.

- **Downwards**: `element.querySelector()`, `element.querySelectorAll()`, `element.childNode`, `element.children[]`, `element.firstChild`, `element.firstElementChild`, `element.lastChild` and `element.lastElementChid`.

Let's describe more with **Generation**:

|Child|Descendant|Parent|Ancestor|
|:-:|:-:|:-:|:-:|
|Direct child node or element|Direct or indirect child node or element|Direct parent node or element|Direct or indirect child node or element|
|`<div><p>A <em>test!</em></p></div>`|`<div><p>A <em>test!</em></p></div>`|`<div><p>A <em>test!</em></p></div>`|`<div><p>A <em>test!</em></p></div>`|
|`<p>` is a child of `<div>`. `<em>` isnâ€™t!|`<p>` is a descendant of `<div>`. So is `<em>`!|`<div>` is a parent of `<p>` but ot of `<em>`!|`<div>` is an ancestor of both `<p>` and `<em>`!|

## Traversing Child Node

Consider this HTML content:

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DOM Interaction</title>
  <script src="app.js" defer></script>
</head>

<body>
  <button id="start-btn">Click me!</button>
  <header>
    <h1 id="main-title">Dive into the DOM!</h1>
  </header>
  <ul>
    <li class="list-item">list1</li>
    <li class="list-item">list2</li>
    <li class="list-item">list3</li>
  </ul>
</body>

</html>
```

If we want to access `ul` elements, we can use `element.childern`. For example:

```js
const ul = document.querySelector("ul");

console.log(ul.children);
/* HTMLCollection(3) [li.list-item, li.list-item, li.list-item]
0: li.list-item
1: li.list-item
2: li.list-item
length: 3
__proto__: HTMLCollection */

console.log(ul.children[1]); // <li class="list-item">list2</li>

console.log(ul.childNodes);
/* NodeList(7) [text, li.list-item, text, li.list-item, text, li.list-item, text]
0: text
1: li.list-item
2: text
3: li.list-item
4: text
5: li.list-item
6: text
length: 7
__proto__: NodeList */
```

As you can see, in `element.childNode`, output also shows **text nodes** (whitespaces included) as `text`. Because `childNode` selects all child nodes whereas `children` only select child element nodes and child nodes therefore also includes text nodes. If you see into the `text`, you will see `data: "â†µ    "`. Because there are `6` whitespaces and `one` line break in front of `li` elements. So this is a **text node**. In this case, whitespaces at the beginning or at the end of the content of an element is typically omitted.

**Warning**: If your whitespaces in between of `pre` tag, they will be render at execution.
**Note**: Of course, you can always do `querySelector('li:last-of-type)` or `querySelector('li:first-of-type')`; that will work, but for `querySele..`, this will cost a little bit of performance. Because `querySelector()` has to scan the entire page and then scan this quite complex CSS query and find the fitting elements and it also just might be redundant if you already got access to the unordered list (`ul`) any way. We recommend to use `element.childNode`, `element.children`, `elemet.firstChild` and `element.firstElementChild` to access the elements (try by your own, no need to describe).

## Using `parentNode` & `parentElement`

Each element can only have on parent. You can have multiple child elements or multiple child nodes, but you can't have more than one parent element or parent node. So, `parentNode` gives us access to the nearest parent node and `parentElement` to the nearest parent element node and in this case, this is actually the same. Only **element nodes** can have child nodes. **Text nodes** can't have child nodes; you can't nest other content into the **text nodes**, they can only hold text, no other nested content.

`element.closest(<CSS selector>)`: **closest** is a nice method for selecting any ancestor anywhere up in the element tree.If you want to pick the nearest descendant element, then of course that would be done with `querySelector()`. For example:

```js
const ul1 = li.parentElement;
console.log(ul1); // <ul>...</ul>

const ul2 = querySelector('ul');
console.log(ul2);
```

## Selecting Sibling Elements

Consider this HTML content:

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DOM Interaction</title>
  <script src="app.js" defer></script>
</head>

<body>
  <button id="start-btn">Click me!</button>
  <header>
    <h1 id="main-title">Dive into the DOM!</h1>
  </header>
  <ul>
    <li class="list-item">list1</li>
    <li class="list-item">list2</li>
    <li class="list-item">list3</li>
  </ul>
</body>

</html>
```

We can access element and node sibling with `element.nextSibling`, `element.previousSibling`, `element.nextElementSibling` and `element.previousElementSibling`. For example:

```js
const ul = document.querySelector("ul");
console.log(ul.previousSibling); // #text -- text node in front of ul tag
console.log(ul.previousElementSibling);
/* <header>
    <h1 id="main-title">Dive into the DOM!</h1>
  </header> */
console.log("----------");
console.log(ul.nextSibling); // #text -- text node before ul tag
console.log(ul.nextElementSibling); // null
```

**Note**: Don't code in strange ways like:

```js
const ul = document.body.firstElementChild.nextElementSibling;
```

`document.body.firstElementChild.nextElementSibling` is simply difficult to understand (reader must inspect all HTML content to find that). So, don't shy and use **query method** if you want to access a complex element.

## Styling DOM Elements

|Via style Property|Via className|Via classList|
|:-:|:-:|:-:|
|Directly target individual CSS styles (on the element)|Directly set the CSS classes assigned to the element|Conveniently add, remove or toggle CSS classes|
|Controls styles as inline styles on the element|Set / Control all classes at once|Fine-grained control over classes that are added|
|Style property names are based on CSS properties but have adjusted names (e.g. backgroundColor)|You can also control the id or other properties|Can be used with className (with care)|

Consider:

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DOM Interaction</title>
  <script src="app.js" defer></script>
  <style>
    .red-bg {
      background-color: red;
      color: white;
      ;
    }

    .visible {
      display: block;
    }

    .invisible {
      display: none;
    }
  </style>
</head>

<body>
  <header>
    <h1 id="main-title">Dive into the DOM!</h1>
  </header>
  <section class="red-bg visible">
    <ul>
      <li class="list-item">list1</li>
      <li class="list-item">list2</li>
      <li class="list-item">list3</li>
    </ul>
  </section>
  <button>Toggle visibility</button>
</body>

</html>
```

We can access the `style` property of elements by `element.style.<CSS>`, for example:

```js
const section = document.querySelector("section");
section.style.backgroundColor = "lightGreen";
```

As you tried, the `section` background color changed to **light green**. You can reach out to the `style` here (in browser console) and set it like this. On the element tab (in developer tools), you'll see that this indeed aded the `style` attribute and reflected your change back into HTML.

We also can add a `class` property: by `element.className`:

```js
const section = document.querySelector("section");
section.className = "red-bg";
```

As you tried, the `section` background color changed to **red** by class name. `red-bg` defined in HTML file, we just set a class name in **JavaScript** file and changing the `section` background color.

**Note**: If you also put `red-bg` in HTML file (`section` part), the class name **not be duplicate** (it just a reference).

Now, we removing the `red-bg` from **JavaScript** and just check the `section` class:

```js
const button = document.querySelector("button");
const section = document.querySelector("section");

const actionButton = () => {
  if (section.className === "red-bg visible") {
    section.className = "red-bg invisible";
  } else {
    section.className = "red-bg visible";
  }
};

button.addEventListener("click", actionButton);
```

As you can see, `class name` changed dynamically (in browse element tab).

Instead of using `if..else`, we can use `classList` object, for example:

```js
const button = document.querySelector("button");
const section = document.querySelector("section");

const actionButton = () => {
  // use old method
  //   if (section.className === "red-bg visible") {
  //     section.className = "red-bg invisible";
  //   } else {
  //     section.className = "red-bg visible";
  //   }

// use new method -- `element.classList.toggle()`
  section.classList.toggle("visible");
  section.classList.toggle("invisible");
};

button.addEventListener("click", actionButton);
```

The element class was toggled between `visible` and `invisible` by `element.classList.toggle()`.

## Creating and Inserting Elements

- HTML string

  - `innerHTML`: Add (render) HTML string.
  - `insertAdjacentHTML`:  Add (render) HTML string in specific position.

- createElement()

  - `appendChild()` / `append()`: Append new DOM element / node.
  - `prepend()`, `before()`, `after()`, `insertBefore()`: Insert new DOM element / node in a specific position.
  - `replaceChild()`, `replaceWith()`: Replace existing DOM element / node with new one.

We can change HTML text content with `element.textContent`. For example:

```js
const section = document.querySelector("section");
section.textContent = "Hey, i will change you";
```

Consider:

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DOM Interaction</title>
  <script src="app.js" defer></script>
  <style>
    .red-bg {
      background-color: red;
      color: white;
      ;
    }

    .visible {
      display: block;
    }

    .invisible {
      display: none;
    }
  </style>
</head>

<body>
  <header>
    <h1 id="main-title">Dive into the DOM!</h1>
  </header>
  <section class="red-bg visible">
    <ul>
      <li class="list-item">list1</li>
      <li class="list-item">list2</li>
      <li class="list-item">list3</li>
    </ul>
  </section>
  <button>Toggle visibility</button>
</body>

</html>
```

If you use `section.textContent` in this HTML content, the output will be:

```js
"

      list1
      list2
      list3

  "
```

We can change HTML content with `element.innerHTML`, for example:

```js
const section = document.querySelector("section");
section.innerHTML = "<h2>Hey, i will change you to header2</h2>";
```

Now we have this `h2` element in there (in console)  but it will always replace all the old HTML content, so any previous nodes between the `section` tags and not just direct child nodes, but any descendant will be **entirely replaced with this new HTML code**. So that's what `innerHTML` does. It really just swaps the entire nested HTML structure, all nested nodes with your new content.

Sometimes you just want to add a single new element and keep the old content and then `innerHTML` is not that great. You can create an element by `element.innerHTML = element.innerHTML + "<li>list4</li>;` (everything gets re-rendered).

**Warning**: Don't do that. It's not good for performance; this has two important implication. **For one**, it's not great for performance, you're forcing the browser to re-parse and re-render a lot of HTML which didn't change at all. **Second**, it will always replace all the old HTML content. What should we do?

A better way of updating this, is using `insertAdjacentHTML()`. This allows you to target a position and then define which HTML you want to enter. Before we use `insertAdjacentHTML()`, let's see some useful parameters and graph:

- `beforebegin`
- `afterbegin`
- `beforeend`
- `afterend`

```html
<!-- graph -->
<!-- beforebegin -->
<p>
  <!-- afterbegin -->
  foo
  <!-- beforeend -->
</p>
<!-- afterend -->
```

Let's work with `insertAdjacentHTML()`:

```js
const ul = document.querySelector("ul");
ul.inserAdjacentHTML("beforeend", "<li>list4</li>");
/* output:
    <ul>
      <li class="list-item">list1</li>
      <li class="list-item">list2</li>
      <li class="list-item">list3</li>
      <li class="list-item">list4</li>
    </ul>
*/
```

The different of `innerHTML` and `insertAdjacentHTML` is, when you use `insertAdjacentHTML`, the code does not re-render everything but really just insert that code and render that new code since you explicitly tell **JavaScript** and the browser that this should be added next to the existing content. This is one way of adding new content to an existing element with some HTML code which you write in **JavaScript** and this is therefore a great way of manipulating this.

## New Ways of Creating and Inserting Elements

The new way of creating elements is using `document.createElement("<tag>")`, for example:

```js
const ul = document.querySelector("ul");
const newLi = document.createElement("li");
```

As you tried, you didn't see changes on display, you need append `newLi` to `ul` element like this:

```js
const ul = document.querySelector("ul");
const newLi = document.createElement("li");
ul.appendChild(newLi);
```

Now you have a dynamic element. Why we said **dynamic**? Because it access to all properties (and other things). For example:

```js
const ul = document.querySelector("ul"); // select `ul` element
const newLi = document.createElement("li"); // create `li` element
ul.appendChild(newLi); // append `li` (add) element to `ul`
newLi.textContent = "list4"; // change `li` text content
newLi.style.backgroundColor = "green"; // change `li` background color to green
```

**Note**: You can also use `document.append()`,and add multiple nodes (like text node) at one time. But the older version of browser, don't support `append()`; we recommend you to use (using) `appandChild()` instead of `appand()`.

If you want to add element to **first index item** of target element, you can use `document.prepend()`. For example:

```js
const ul = document.querySelector("ul"); // select `ul` element
const newLi = document.createElement("li"); // create `li` element
ul.prepend(newLi); // prepend `li` (add) element to `ul`
/* output:
    <ul>
      <li class="list-item">list4</li>
      <li class="list-item">list1</li>
      <li class="list-item">list2</li>
      <li class="list-item">list3</li>
    </ul>
*/
```

**Note**: An alternative that does work on **Internet Explorer**, is `element.insertBefore()`. But **IE** will die soon (at 2021).

You can change position of element, for example:

```js
const ul = document.querySelector("ul"); // select `ul` element
const newLi = document.createElement("li"); // create `li` element
ul.prepend(newLi); // prepend `li` (add) element to `ul`
newLi.textContent = "list4"; // change `li` text content
newLi.style.backgroundColor = "green"; // change `li` background color to green

ul.lastElementChild.before(newLi); // move new `li` from first to `before last element` of `ul`
/* output:
    <ul>
      <li class="list-item">list1</li>
      <li class="list-item">list2</li>
      <li class="list-item">list4</li>
      <li class="list-item">list3</li>
    </ul>
*/
```

You can easily talk to **JavaScript**. This (above code) is not copied or anything like that, insted the existing element is detached from the place where it was and moveed to the new place. Because **object** are reference values as you learned and DOM objects you're working here are nothing but normal objects in the end, and therefore if we do something with it and we add it somewhere else, we always work with the same object; so of course it's detached from the existing place and moved to the new one.

We can also use `ul.lastElementChild.before(newLi);` and `ul.lastElementChild.replaceWith(newLi);`. These are different ways of inserting this in different places.

**Important**: `append`, `before`, `after` and so on, they all take multiple nodes if you want.

Or the last and least, we can use `element.insertAdjacentElement()`. Before we use `insertAdjacentElement()`, let's see some useful parameters:

- `beforebegin`
- `afterbegin`
- `beforeend`
- `afterend`

Consider:

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DOM Interaction</title>
  <script src="app.js" defer></script>
  <style>
    .red-bg {
      background-color: red;
      color: white;
      ;
    }

    .visible {
      display: block;
    }

    .invisible {
      display: none;
    }
  </style>
</head>

<body>
  <header>
    <h1 id="main-title">Dive into the DOM!</h1>
  </header>
  <section class="red-bg visible">
    <ul>
      <li class="list-item">list1</li>
      <li class="list-item">list2</li>
      <li class="list-item">list3</li>
    </ul>
  </section>
  <button>Toggle visibility</button>
</body>

</html>
```

Example: We want move second element of `ul` to first index, we want do it with `insertAdjacentElement()`, then:

```js
const list = document.querySelector("ul");
const secondLi = list.children[1];

list.insertAdjacentElement('afterbegin', secondLi);
/* output:
    <ul>
      <li class="list-item">list2</li>
      <li class="list-item">list1</li>
      <li class="list-item">list3</li>
    </ul>
*/
```

We can clone a node with `element.cloneNode()` code, for example:

```js
const list = document.querySelector("ul");
const secondLi = list.children[1];

const newLi = secondLi.cloneNode(true);
list.append(newLi);
/* output:
    <ul>
      <li class="list-item">list2</li>
      <li class="list-item">list1</li>
      <li class="list-item">list3</li>
      <li class="list-item">list2</li> -- new
    </ul>
*/
```

As you can see, `list2` was cloned. If we pass `true` in `cloneNode()`, all status and all children nodes will be clone. Default value is `false`, then only clone that element (raw element).

## Live and Static Node List

What are they?

consider:

```js
const list = document.querySelector("ul");
const listItems = list.querySelectorAll("li");
const listItems2 = list.getElementsByTagName("li");
console.log(listItems);
console.log(listItems2);
```

As you can see, `listItems` is **NodeList** and `listItems2` is **HTMLCollection**.
