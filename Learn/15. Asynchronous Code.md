# Asynchronous Code

In this course, you will learn about:

- What is **Async Code**
- Working with  Callbacks
- Promises
- `async` / `await`

## Synchronous Code Execution

**JavaScript** is single-threaded, it can only execute one task at a time, consider:

```js
const button = document.querySelector("button");
const output = document.querySelector("p");

function trackUserHandler() {}

button.addEventListener("click", trackUserHandler);
```

**JavaScript** parses and executes our code from top to buttom. In above code, **JavaScript** selects that `<button>` and stores it in a constant. Then only once first line finished, the second line is executed and this task is performed.

When **JavaScript** reads the file at the beginning, the in the execution process, this `button.addEventListener...` line executes after these two lines (first and second) executed. Because we need the `button` to be available in order to add an event listener. So we rely on this order which is enforced by **JavaScript**.

Multi-thread is bad for **JavaScript**. If it would be multi-threaded, it could maybe execute all tasks at the same time and here this would actually be bad, because we could not rely on the `button` to be available when we need it. For example, if `button.addEventListener...` line is executed at the same time as `const button = document...` line, then the `button` might not have been selected yet and therefore adding an event listener to it would maybe fail.

## Asynchronous Code Execution

Consider this code:

```js
const button = document.querySelector("button");
const p = document.querySelector("p");

function trackUserHandler() {
  console.log("Hello");
}

button.addEventListener("click", trackUserHandler);

let result = 0;

for (let i = 0; i < 1000000; i++) {
  result += i;
}

console.log(result);
```

We clicked on that `button`, then this click is registered and the browser pushes `trackUserHandler` function as a **to-do** onto our message queue, but the event loop sees that we still have work to do on the call stack and therefore, it waits to execute `trackUserHandler` function until the call stack is empty; that only happens once `for` loop executed, and once we logged `console.log(result)` to the console which is why we see the clicked output only after we see the `for` loop result, even if we click the button whilst this was still going on, because of how the browser handles this.

Let's see another example:

```js
const button = document.querySelector("button");
const p = document.querySelector("p");

function trackUserHandler() {
  navigator.geolocation.getCurrentPosition(
    (posData) => console.log(posData),
    (error) => console.log(error)
  );
}

button.addEventListener("click", trackUserHandler);

let result = 0;

for (let i = 0; i < 1000000; i++) {
  result += i;
}

console.log(result);
/*
Block: GeolocationPositionError {code: 1, message: "User denied Geolocation"}
Allow: Position: {coords: Coordinates, timestamp: 1568621297168}
or
GeolocationPositionError {code: 2, message: "Network location provider at 'https://www.googleapis.com/' : No response received."}
*/
```

As we said before, it **pushes it into the message queue** where the **event loop eventually movies it** into the **JavaScript** call stack. If we put `console.log("Hamid")` after that function, we will see:

```js
const button = document.querySelector("button");
const p = document.querySelector("p");

function trackUserHandler() {
  navigator.geolocation.getCurrentPosition(
    (posData) => console.log(posData),
    (error) => console.log(error)
  );
  console.log("Hamid");
}

button.addEventListener("click", trackUserHandler);

let result = 0;

for (let i = 0; i < 1000000; i++) {
  result += i;
}

console.log(result);
/*
"Hamid"
Block: GeolocationPositionError {code: 1, message: "User denied Geolocation"}
Allow: Position: {coords: Coordinates, timestamp: 1568621297168}
or
GeolocationPositionError {code: 2, message: "Network location provider at 'https://www.googleapis.com/' : No response received."}
*/
```

As you can see, we see that the `"hamid"` was printed first. Because **JavaScript** is non-blocking.

## Callback

Consider:

```js
const button = document.querySelector("button");
const p = document.querySelector("p");

function trackUserHandler() {
  navigator.geolocation.getCurrentPosition(
    (posData) => setTimeout(() => console.log(posData), 4000),
    (error) => console.log(error)
  );
  setTimeout(() => console.log("Timer done"), 0);
  console.log("Getting positions...");
}

button.addEventListener("click", trackUserHandler);

/*
Getting positions...
test.js:9 Timer done
test.js:7 GeolocationPositionError {code: 2, message: "Network location provider at 'https://www.googleapis.com/' : No response received."}
*/
```

`console.log("Getting positions...")` code always executes first, this executes right away after `setTimeout()` (i.e. `"Timer don"`) executes; and even though the timer immediately finishes, this function still only executes after `console.log("Getting positions...")` line is done.

In `setTimeout(() => console.log("Timer done"), 0);` line, `0` is the minimum time after which the callback function will be executed. **It's not the guaranteed time**; if it were guaranteed, it would need to run immediately. If we had the long running `for` loop instead of `console.log("Getting positions...")`, then this `setTimeout(() => console.log("Timer done"), 0)` timer would only execute once the long running `for` loop is done which might take three seconds.

**Note**: `0` is not a zero value, it's a minimum value in `setTimeout()` and `setInterval()` methods. It's not the guaranteed time.

## Promises

Let's consider this snippet:

```js
// Callback
navigator.geolocation.getCurrentPosition(() =>
  setTimeout(() => doMoreAsyncStuff(() => console.log("Helllo")), 1000)
);
```

It's hard to understand, it's cumbersome to read this code. Thankfully **JavaScript** bring us the **Promises** to solve this issue. Let's consider this code:

```js
// Promise
someAsyncTask()
  .then(() => anotherTask())
  .then(() => yetAnotherTask())
  .then();
```

As you can see, we have better and easier way to doing our tasks. In this code, we add another `then` block instead of nesting it into each other; and therefore we have only **one level of nesting here instead of having multiple levels**.

We can use promises with the `Promise` constructor. The `Promise` object skeleton is:

```js
const promise = new Promise((resolve, reject) => { });
```

Let's work with the promises:

```js
const setTimer = (duration) => {
  const promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Done!"), duration);
  });
  return promise;
};

function trackUserHandler() {
  navigator.geolocation.getCurrentPosition(
    (posData) => setTimer(2000).then((data) => console.log(data, posData)),
    (error) => console.log(error)
  );
  console.log("Getting positions...");
}

const button = document.querySelector("button");
button.addEventListener("click", trackUserHandler);

/*
Getting positions...
Done! GeolocationPosition {coords: GeolocationCoordinates, timestamp: 1601954982558}
*/
```

Or we can pass the location into a new promise, for example:

```js
const getPosition = (options) => {
  const promise = new Promise((resolve, reject) => {
    navigator.geolocation.getCurrentPosition(
      (success) => resolve(success),
      (error) => console.log(error),
      options
    );
  });
  return promise;
};

const setTimer = (duration) => {
  const promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Done!"), duration);
  });
  return promise;
};

function trackUserHandler() {
  let positionData;
  getPosition()
    .then((posData) => {
      positionData = posData;
      return setTimer(2000);
    })
    .then((data) => console.log(data, positionData));
  setTimer(1000).then(() => {
    console.log("Timer done!");
  });
  console.log("Getting positions...");
}

const button = document.querySelector("button");
button.addEventListener("click", trackUserHandler);
```

As you can see, we have multiple steps in this (in `getPosition`) promise, where we wait for the first promise (i.e. `getPosition()`) to finish and then we return `setTimer()` which doesn't even have to be a promise by the way. If it would be other data like a string (i.e. `return 'setTimer(2000)'`), it would be wrapped into a promise automatically. Then we'll wait for this promise to resolve, then once this promise finished, we move on to the next `.then` step and execute that with the data of that returned promise (i.e. `return setTimer(2000)`).

This is promise chaining and this is a powerful concept which lets you escape from **callback hell**. Because now we have **step after step** instead of **step inside step** would lead to a lot of nesting, if you have a lot of related operation.
